// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v3.21.6
// source: cloud/batch/v1/data.proto

package batchdata

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Task states.
type TaskStatus_State int32

const (
	// Unknown state.
	TaskStatus_STATE_UNSPECIFIED TaskStatus_State = 0
	// The Task is created and waiting for resources.
	TaskStatus_PENDING TaskStatus_State = 1
	// The Task is assigned to at least one VM.
	TaskStatus_ASSIGNED TaskStatus_State = 2
	// The Task is running.
	TaskStatus_RUNNING TaskStatus_State = 3
	// The Task has failed.
	TaskStatus_FAILED TaskStatus_State = 4
	// The Task has succeeded.
	TaskStatus_SUCCEEDED TaskStatus_State = 5
	// The Task has not been executed when the Job finishes.
	TaskStatus_UNEXECUTED TaskStatus_State = 6
)

// Enum value maps for TaskStatus_State.
var (
	TaskStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "PENDING",
		2: "ASSIGNED",
		3: "RUNNING",
		4: "FAILED",
		5: "SUCCEEDED",
		6: "UNEXECUTED",
	}
	TaskStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"PENDING":           1,
		"ASSIGNED":          2,
		"RUNNING":           3,
		"FAILED":            4,
		"SUCCEEDED":         5,
		"UNEXECUTED":        6,
	}
)

func (x TaskStatus_State) Enum() *TaskStatus_State {
	p := new(TaskStatus_State)
	*p = x
	return p
}

func (x TaskStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TaskStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[0].Descriptor()
}

func (TaskStatus_State) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[0]
}

func (x TaskStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TaskStatus_State.Descriptor instead.
func (TaskStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{6, 0}
}

// Action on task failures based on different conditions.
type LifecyclePolicy_Action int32

const (
	// Action unspecified.
	LifecyclePolicy_ACTION_UNSPECIFIED LifecyclePolicy_Action = 0
	// Action that tasks in the group will be scheduled to re-execute.
	LifecyclePolicy_RETRY_TASK LifecyclePolicy_Action = 1
	// Action that tasks in the group will be stopped immediately.
	LifecyclePolicy_FAIL_TASK LifecyclePolicy_Action = 2
)

// Enum value maps for LifecyclePolicy_Action.
var (
	LifecyclePolicy_Action_name = map[int32]string{
		0: "ACTION_UNSPECIFIED",
		1: "RETRY_TASK",
		2: "FAIL_TASK",
	}
	LifecyclePolicy_Action_value = map[string]int32{
		"ACTION_UNSPECIFIED": 0,
		"RETRY_TASK":         1,
		"FAIL_TASK":          2,
	}
)

func (x LifecyclePolicy_Action) Enum() *LifecyclePolicy_Action {
	p := new(LifecyclePolicy_Action)
	*p = x
	return p
}

func (x LifecyclePolicy_Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LifecyclePolicy_Action) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[1].Descriptor()
}

func (LifecyclePolicy_Action) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[1]
}

func (x LifecyclePolicy_Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LifecyclePolicy_Action.Descriptor instead.
func (LifecyclePolicy_Action) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{9, 0}
}

// The destination (if any) for logs.
type LogsPolicy_Destination int32

const (
	// Logs are not preserved.
	LogsPolicy_DESTINATION_UNSPECIFIED LogsPolicy_Destination = 0
	// Logs are streamed to Cloud Logging.
	LogsPolicy_CLOUD_LOGGING LogsPolicy_Destination = 1
	// Logs are saved to a file path.
	LogsPolicy_PATH LogsPolicy_Destination = 2
)

// Enum value maps for LogsPolicy_Destination.
var (
	LogsPolicy_Destination_name = map[int32]string{
		0: "DESTINATION_UNSPECIFIED",
		1: "CLOUD_LOGGING",
		2: "PATH",
	}
	LogsPolicy_Destination_value = map[string]int32{
		"DESTINATION_UNSPECIFIED": 0,
		"CLOUD_LOGGING":           1,
		"PATH":                    2,
	}
)

func (x LogsPolicy_Destination) Enum() *LogsPolicy_Destination {
	p := new(LogsPolicy_Destination)
	*p = x
	return p
}

func (x LogsPolicy_Destination) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogsPolicy_Destination) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[2].Descriptor()
}

func (LogsPolicy_Destination) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[2]
}

func (x LogsPolicy_Destination) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogsPolicy_Destination.Descriptor instead.
func (LogsPolicy_Destination) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{12, 0}
}

// Valid Job states.
type JobStatus_State int32

const (
	// Job state unspecified.
	JobStatus_STATE_UNSPECIFIED JobStatus_State = 0
	// Job is admitted (validated and persisted) and waiting for resources.
	JobStatus_QUEUED JobStatus_State = 1
	// Job is scheduled to run as soon as resource allocation is ready.
	// The resource allocation may happen at a later time but with a high
	// chance to succeed.
	JobStatus_SCHEDULED JobStatus_State = 2
	// Resource allocation has been successful. At least one Task in the Job is
	// RUNNING.
	JobStatus_RUNNING JobStatus_State = 3
	// All Tasks in the Job have finished successfully.
	JobStatus_SUCCEEDED JobStatus_State = 4
	// At least one Task in the Job has failed.
	JobStatus_FAILED JobStatus_State = 5
	// The Job will be deleted, but has not been deleted yet. Typically this is
	// because resources used by the Job are still being cleaned up.
	JobStatus_DELETION_IN_PROGRESS JobStatus_State = 6
)

// Enum value maps for JobStatus_State.
var (
	JobStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "QUEUED",
		2: "SCHEDULED",
		3: "RUNNING",
		4: "SUCCEEDED",
		5: "FAILED",
		6: "DELETION_IN_PROGRESS",
	}
	JobStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED":    0,
		"QUEUED":               1,
		"SCHEDULED":            2,
		"RUNNING":              3,
		"SUCCEEDED":            4,
		"FAILED":               5,
		"DELETION_IN_PROGRESS": 6,
	}
)

func (x JobStatus_State) Enum() *JobStatus_State {
	p := new(JobStatus_State)
	*p = x
	return p
}

func (x JobStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (JobStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[3].Descriptor()
}

func (JobStatus_State) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[3]
}

func (x JobStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use JobStatus_State.Descriptor instead.
func (JobStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{13, 0}
}

// The message type.
type JobNotification_Type int32

const (
	// Unspecified.
	JobNotification_TYPE_UNSPECIFIED JobNotification_Type = 0
	// Notify users that the job state has changed.
	JobNotification_JOB_STATE_CHANGED JobNotification_Type = 1
	// Notify users that the task state has changed.
	JobNotification_TASK_STATE_CHANGED JobNotification_Type = 2
)

// Enum value maps for JobNotification_Type.
var (
	JobNotification_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "JOB_STATE_CHANGED",
		2: "TASK_STATE_CHANGED",
	}
	JobNotification_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED":   0,
		"JOB_STATE_CHANGED":  1,
		"TASK_STATE_CHANGED": 2,
	}
)

func (x JobNotification_Type) Enum() *JobNotification_Type {
	p := new(JobNotification_Type)
	*p = x
	return p
}

func (x JobNotification_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (JobNotification_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[4].Descriptor()
}

func (JobNotification_Type) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[4]
}

func (x JobNotification_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use JobNotification_Type.Descriptor instead.
func (JobNotification_Type) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{14, 0}
}

// Compute Engine VM instance provisioning model.
type AllocationPolicy_ProvisioningModel int32

const (
	// Unspecified.
	AllocationPolicy_PROVISIONING_MODEL_UNSPECIFIED AllocationPolicy_ProvisioningModel = 0
	// Standard VM.
	AllocationPolicy_STANDARD AllocationPolicy_ProvisioningModel = 1
	// SPOT VM.
	AllocationPolicy_SPOT AllocationPolicy_ProvisioningModel = 2
	// Preemptible VM (PVM).
	//
	// Above SPOT VM is the preferable model for preemptible VM instances: the
	// old preemptible VM model (indicated by this field) is the older model,
	// and has been migrated to use the SPOT model as the underlying technology.
	// This old model will still be supported.
	AllocationPolicy_PREEMPTIBLE AllocationPolicy_ProvisioningModel = 3
)

// Enum value maps for AllocationPolicy_ProvisioningModel.
var (
	AllocationPolicy_ProvisioningModel_name = map[int32]string{
		0: "PROVISIONING_MODEL_UNSPECIFIED",
		1: "STANDARD",
		2: "SPOT",
		3: "PREEMPTIBLE",
	}
	AllocationPolicy_ProvisioningModel_value = map[string]int32{
		"PROVISIONING_MODEL_UNSPECIFIED": 0,
		"STANDARD":                       1,
		"SPOT":                           2,
		"PREEMPTIBLE":                    3,
	}
)

func (x AllocationPolicy_ProvisioningModel) Enum() *AllocationPolicy_ProvisioningModel {
	p := new(AllocationPolicy_ProvisioningModel)
	*p = x
	return p
}

func (x AllocationPolicy_ProvisioningModel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AllocationPolicy_ProvisioningModel) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[5].Descriptor()
}

func (AllocationPolicy_ProvisioningModel) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[5]
}

func (x AllocationPolicy_ProvisioningModel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AllocationPolicy_ProvisioningModel.Descriptor instead.
func (AllocationPolicy_ProvisioningModel) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 0}
}

// How Tasks in the TaskGroup should be scheduled relative to each other.
type TaskGroup_SchedulingPolicy int32

const (
	// Unspecified.
	TaskGroup_SCHEDULING_POLICY_UNSPECIFIED TaskGroup_SchedulingPolicy = 0
	// Run Tasks as soon as resources are available.
	//
	// Tasks might be executed in parallel depending on parallelism and
	// task_count values.
	TaskGroup_AS_SOON_AS_POSSIBLE TaskGroup_SchedulingPolicy = 1
	// Run Tasks sequentially with increased task index.
	TaskGroup_IN_ORDER TaskGroup_SchedulingPolicy = 2
)

// Enum value maps for TaskGroup_SchedulingPolicy.
var (
	TaskGroup_SchedulingPolicy_name = map[int32]string{
		0: "SCHEDULING_POLICY_UNSPECIFIED",
		1: "AS_SOON_AS_POSSIBLE",
		2: "IN_ORDER",
	}
	TaskGroup_SchedulingPolicy_value = map[string]int32{
		"SCHEDULING_POLICY_UNSPECIFIED": 0,
		"AS_SOON_AS_POSSIBLE":           1,
		"IN_ORDER":                      2,
	}
)

func (x TaskGroup_SchedulingPolicy) Enum() *TaskGroup_SchedulingPolicy {
	p := new(TaskGroup_SchedulingPolicy)
	*p = x
	return p
}

func (x TaskGroup_SchedulingPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TaskGroup_SchedulingPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_batch_v1_data_proto_enumTypes[6].Descriptor()
}

func (TaskGroup_SchedulingPolicy) Type() protoreflect.EnumType {
	return &file_cloud_batch_v1_data_proto_enumTypes[6]
}

func (x TaskGroup_SchedulingPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TaskGroup_SchedulingPolicy.Descriptor instead.
func (TaskGroup_SchedulingPolicy) EnumDescriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{16, 0}
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type Volume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The source for the volume.
	//
	// Types that are valid to be assigned to Source:
	//
	//	*Volume_Nfs
	//	*Volume_Gcs
	//	*Volume_DeviceName
	Source isVolume_Source `protobuf_oneof:"source"`
	// The mount path for the volume, e.g. /mnt/disks/share.
	MountPath string `protobuf:"bytes,4,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	// For Google Cloud Storage (GCS), mount options are the options supported by
	// the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse).
	// For existing persistent disks, mount options provided by the
	// mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except
	// writing are supported. This is due to restrictions of multi-writer mode
	// (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms).
	// For other attached disks and Network File System (NFS), mount options are
	// these supported by the mount command
	// (https://man7.org/linux/man-pages/man8/mount.8.html).
	MountOptions  []string `protobuf:"bytes,5,rep,name=mount_options,json=mountOptions,proto3" json:"mount_options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Volume) Reset() {
	*x = Volume{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Volume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Volume) ProtoMessage() {}

func (x *Volume) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Volume.ProtoReflect.Descriptor instead.
func (*Volume) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{0}
}

func (x *Volume) GetSource() isVolume_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Volume) GetNfs() *NFS {
	if x != nil {
		if x, ok := x.Source.(*Volume_Nfs); ok {
			return x.Nfs
		}
	}
	return nil
}

func (x *Volume) GetGcs() *GCS {
	if x != nil {
		if x, ok := x.Source.(*Volume_Gcs); ok {
			return x.Gcs
		}
	}
	return nil
}

func (x *Volume) GetDeviceName() string {
	if x != nil {
		if x, ok := x.Source.(*Volume_DeviceName); ok {
			return x.DeviceName
		}
	}
	return ""
}

func (x *Volume) GetMountPath() string {
	if x != nil {
		return x.MountPath
	}
	return ""
}

func (x *Volume) GetMountOptions() []string {
	if x != nil {
		return x.MountOptions
	}
	return nil
}

type isVolume_Source interface {
	isVolume_Source()
}

type Volume_Nfs struct {
	// A Network File System (NFS) volume. For example, a
	// Filestore file share.
	Nfs *NFS `protobuf:"bytes,1,opt,name=nfs,proto3,oneof"`
}

type Volume_Gcs struct {
	// A Google Cloud Storage (GCS) volume.
	Gcs *GCS `protobuf:"bytes,3,opt,name=gcs,proto3,oneof"`
}

type Volume_DeviceName struct {
	// Device name of an attached disk volume, which should align with a
	// device_name specified by
	// job.allocation_policy.instances[0].policy.disks[i].device_name or
	// defined by the given instance template in
	// job.allocation_policy.instances[0].instance_template.
	DeviceName string `protobuf:"bytes,6,opt,name=device_name,json=deviceName,proto3,oneof"`
}

func (*Volume_Nfs) isVolume_Source() {}

func (*Volume_Gcs) isVolume_Source() {}

func (*Volume_DeviceName) isVolume_Source() {}

// Represents an NFS volume.
type NFS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The IP address of the NFS.
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Remote source path exported from the NFS, e.g., "/share".
	RemotePath    string `protobuf:"bytes,2,opt,name=remote_path,json=remotePath,proto3" json:"remote_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFS) Reset() {
	*x = NFS{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFS) ProtoMessage() {}

func (x *NFS) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFS.ProtoReflect.Descriptor instead.
func (*NFS) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{1}
}

func (x *NFS) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *NFS) GetRemotePath() string {
	if x != nil {
		return x.RemotePath
	}
	return ""
}

// Represents a Google Cloud Storage volume.
type GCS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Remote path, either a bucket name or a subdirectory of a bucket, e.g.:
	// bucket_name, bucket_name/subdirectory/
	RemotePath    string `protobuf:"bytes,1,opt,name=remote_path,json=remotePath,proto3" json:"remote_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GCS) Reset() {
	*x = GCS{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCS) ProtoMessage() {}

func (x *GCS) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCS.ProtoReflect.Descriptor instead.
func (*GCS) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{2}
}

func (x *GCS) GetRemotePath() string {
	if x != nil {
		return x.RemotePath
	}
	return ""
}

// Compute resource requirements
type ComputeResource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The milliCPU count.
	CpuMilli int64 `protobuf:"varint,1,opt,name=cpu_milli,json=cpuMilli,proto3" json:"cpu_milli,omitempty"`
	// Memory in MiB.
	MemoryMib int64 `protobuf:"varint,2,opt,name=memory_mib,json=memoryMib,proto3" json:"memory_mib,omitempty"`
	// Extra boot disk size in MiB for each task.
	BootDiskMib   int64 `protobuf:"varint,4,opt,name=boot_disk_mib,json=bootDiskMib,proto3" json:"boot_disk_mib,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputeResource) Reset() {
	*x = ComputeResource{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeResource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeResource) ProtoMessage() {}

func (x *ComputeResource) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeResource.ProtoReflect.Descriptor instead.
func (*ComputeResource) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{3}
}

func (x *ComputeResource) GetCpuMilli() int64 {
	if x != nil {
		return x.CpuMilli
	}
	return 0
}

func (x *ComputeResource) GetMemoryMib() int64 {
	if x != nil {
		return x.MemoryMib
	}
	return 0
}

func (x *ComputeResource) GetBootDiskMib() int64 {
	if x != nil {
		return x.BootDiskMib
	}
	return 0
}

// Status event
type StatusEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of the event.
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// Description of the event.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The time this event occurred.
	EventTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=event_time,json=eventTime,proto3" json:"event_time,omitempty"`
	// Task Execution
	TaskExecution *TaskExecution `protobuf:"bytes,4,opt,name=task_execution,json=taskExecution,proto3" json:"task_execution,omitempty"`
	// Task State
	TaskState     TaskStatus_State `protobuf:"varint,5,opt,name=task_state,json=taskState,proto3,enum=google.events.cloud.batch.v1.TaskStatus_State" json:"task_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusEvent) Reset() {
	*x = StatusEvent{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusEvent) ProtoMessage() {}

func (x *StatusEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusEvent.ProtoReflect.Descriptor instead.
func (*StatusEvent) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{4}
}

func (x *StatusEvent) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *StatusEvent) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *StatusEvent) GetEventTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EventTime
	}
	return nil
}

func (x *StatusEvent) GetTaskExecution() *TaskExecution {
	if x != nil {
		return x.TaskExecution
	}
	return nil
}

func (x *StatusEvent) GetTaskState() TaskStatus_State {
	if x != nil {
		return x.TaskState
	}
	return TaskStatus_STATE_UNSPECIFIED
}

// This Task Execution field includes detail information for
// task execution procedures, based on StatusEvent types.
type TaskExecution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When task is completed as the status of FAILED or SUCCEEDED,
	// exit code is for one task execution result, default is 0 as success.
	ExitCode      int32 `protobuf:"varint,1,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskExecution) Reset() {
	*x = TaskExecution{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskExecution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskExecution) ProtoMessage() {}

func (x *TaskExecution) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskExecution.ProtoReflect.Descriptor instead.
func (*TaskExecution) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{5}
}

func (x *TaskExecution) GetExitCode() int32 {
	if x != nil {
		return x.ExitCode
	}
	return 0
}

// Status of a task
type TaskStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskStatus) Reset() {
	*x = TaskStatus{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskStatus) ProtoMessage() {}

func (x *TaskStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskStatus.ProtoReflect.Descriptor instead.
func (*TaskStatus) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{6}
}

// Runnable describes instructions for executing a specific script or container
// as part of a Task.
type Runnable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The script or container to run.
	//
	// Types that are valid to be assigned to Executable:
	//
	//	*Runnable_Container_
	//	*Runnable_Script_
	//	*Runnable_Barrier_
	Executable isRunnable_Executable `protobuf_oneof:"executable"`
	// Normally, a non-zero exit status causes the Task to fail. This flag allows
	// execution of other Runnables to continue instead.
	IgnoreExitStatus bool `protobuf:"varint,3,opt,name=ignore_exit_status,json=ignoreExitStatus,proto3" json:"ignore_exit_status,omitempty"`
	// This flag allows a Runnable to continue running in the background while the
	// Task executes subsequent Runnables. This is useful to provide services to
	// other Runnables (or to provide debugging support tools like SSH servers).
	Background bool `protobuf:"varint,4,opt,name=background,proto3" json:"background,omitempty"`
	// By default, after a Runnable fails, no further Runnable are executed. This
	// flag indicates that this Runnable must be run even if the Task has already
	// failed. This is useful for Runnables that copy output files off of the VM
	// or for debugging.
	//
	// The always_run flag does not override the Task's overall max_run_duration.
	// If the max_run_duration has expired then no further Runnables will execute,
	// not even always_run Runnables.
	AlwaysRun bool `protobuf:"varint,5,opt,name=always_run,json=alwaysRun,proto3" json:"always_run,omitempty"`
	// Environment variables for this Runnable (overrides variables set for the
	// whole Task or TaskGroup).
	Environment *Environment `protobuf:"bytes,7,opt,name=environment,proto3" json:"environment,omitempty"`
	// Timeout for this Runnable.
	Timeout *durationpb.Duration `protobuf:"bytes,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Labels for this Runnable.
	Labels        map[string]string `protobuf:"bytes,9,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Runnable) Reset() {
	*x = Runnable{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Runnable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Runnable) ProtoMessage() {}

func (x *Runnable) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Runnable.ProtoReflect.Descriptor instead.
func (*Runnable) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{7}
}

func (x *Runnable) GetExecutable() isRunnable_Executable {
	if x != nil {
		return x.Executable
	}
	return nil
}

func (x *Runnable) GetContainer() *Runnable_Container {
	if x != nil {
		if x, ok := x.Executable.(*Runnable_Container_); ok {
			return x.Container
		}
	}
	return nil
}

func (x *Runnable) GetScript() *Runnable_Script {
	if x != nil {
		if x, ok := x.Executable.(*Runnable_Script_); ok {
			return x.Script
		}
	}
	return nil
}

func (x *Runnable) GetBarrier() *Runnable_Barrier {
	if x != nil {
		if x, ok := x.Executable.(*Runnable_Barrier_); ok {
			return x.Barrier
		}
	}
	return nil
}

func (x *Runnable) GetIgnoreExitStatus() bool {
	if x != nil {
		return x.IgnoreExitStatus
	}
	return false
}

func (x *Runnable) GetBackground() bool {
	if x != nil {
		return x.Background
	}
	return false
}

func (x *Runnable) GetAlwaysRun() bool {
	if x != nil {
		return x.AlwaysRun
	}
	return false
}

func (x *Runnable) GetEnvironment() *Environment {
	if x != nil {
		return x.Environment
	}
	return nil
}

func (x *Runnable) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *Runnable) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

type isRunnable_Executable interface {
	isRunnable_Executable()
}

type Runnable_Container_ struct {
	// Container runnable.
	Container *Runnable_Container `protobuf:"bytes,1,opt,name=container,proto3,oneof"`
}

type Runnable_Script_ struct {
	// Script runnable.
	Script *Runnable_Script `protobuf:"bytes,2,opt,name=script,proto3,oneof"`
}

type Runnable_Barrier_ struct {
	// Barrier runnable.
	Barrier *Runnable_Barrier `protobuf:"bytes,6,opt,name=barrier,proto3,oneof"`
}

func (*Runnable_Container_) isRunnable_Executable() {}

func (*Runnable_Script_) isRunnable_Executable() {}

func (*Runnable_Barrier_) isRunnable_Executable() {}

// Spec of a task
type TaskSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sequence of scripts or containers to run for this Task. Each Task using
	// this TaskSpec executes its list of runnables in order. The Task succeeds if
	// all of its runnables either exit with a zero status or any that exit with a
	// non-zero status have the ignore_exit_status flag.
	//
	// Background runnables are killed automatically (if they have not already
	// exited) a short time after all foreground runnables have completed. Even
	// though this is likely to result in a non-zero exit status for the
	// background runnable, these automatic kills are not treated as Task
	// failures.
	Runnables []*Runnable `protobuf:"bytes,8,rep,name=runnables,proto3" json:"runnables,omitempty"`
	// ComputeResource requirements.
	ComputeResource *ComputeResource `protobuf:"bytes,3,opt,name=compute_resource,json=computeResource,proto3" json:"compute_resource,omitempty"`
	// Maximum duration the task should run.
	// The task will be killed and marked as FAILED if over this limit.
	MaxRunDuration *durationpb.Duration `protobuf:"bytes,4,opt,name=max_run_duration,json=maxRunDuration,proto3" json:"max_run_duration,omitempty"`
	// Maximum number of retries on failures.
	// The default, 0, which means never retry.
	// The valid value range is [0, 10].
	MaxRetryCount int32 `protobuf:"varint,5,opt,name=max_retry_count,json=maxRetryCount,proto3" json:"max_retry_count,omitempty"`
	// Lifecycle management schema when any task in a task group is failed.
	// Currently we only support one lifecycle policy.
	// When the lifecycle policy condition is met,
	// the action in the policy will execute.
	// If task execution result does not meet with the defined lifecycle
	// policy, we consider it as the default policy.
	// Default policy means if the exit code is 0, exit task.
	// If task ends with non-zero exit code, retry the task with max_retry_count.
	LifecyclePolicies []*LifecyclePolicy `protobuf:"bytes,9,rep,name=lifecycle_policies,json=lifecyclePolicies,proto3" json:"lifecycle_policies,omitempty"`
	// Deprecated: please use environment(non-plural) instead.
	Environments map[string]string `protobuf:"bytes,6,rep,name=environments,proto3" json:"environments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volumes to mount before running Tasks using this TaskSpec.
	Volumes []*Volume `protobuf:"bytes,7,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Environment variables to set before running the Task.
	Environment   *Environment `protobuf:"bytes,10,opt,name=environment,proto3" json:"environment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskSpec) Reset() {
	*x = TaskSpec{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskSpec) ProtoMessage() {}

func (x *TaskSpec) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskSpec.ProtoReflect.Descriptor instead.
func (*TaskSpec) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{8}
}

func (x *TaskSpec) GetRunnables() []*Runnable {
	if x != nil {
		return x.Runnables
	}
	return nil
}

func (x *TaskSpec) GetComputeResource() *ComputeResource {
	if x != nil {
		return x.ComputeResource
	}
	return nil
}

func (x *TaskSpec) GetMaxRunDuration() *durationpb.Duration {
	if x != nil {
		return x.MaxRunDuration
	}
	return nil
}

func (x *TaskSpec) GetMaxRetryCount() int32 {
	if x != nil {
		return x.MaxRetryCount
	}
	return 0
}

func (x *TaskSpec) GetLifecyclePolicies() []*LifecyclePolicy {
	if x != nil {
		return x.LifecyclePolicies
	}
	return nil
}

func (x *TaskSpec) GetEnvironments() map[string]string {
	if x != nil {
		return x.Environments
	}
	return nil
}

func (x *TaskSpec) GetVolumes() []*Volume {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *TaskSpec) GetEnvironment() *Environment {
	if x != nil {
		return x.Environment
	}
	return nil
}

// LifecyclePolicy describes how to deal with task failures
// based on different conditions.
type LifecyclePolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Action to execute when ActionCondition is true.
	// When RETRY_TASK is specified, we will retry failed tasks
	// if we notice any exit code match and fail tasks if no match is found.
	// Likewise, when FAIL_TASK is specified, we will fail tasks
	// if we notice any exit code match and retry tasks if no match is found.
	Action LifecyclePolicy_Action `protobuf:"varint,1,opt,name=action,proto3,enum=google.events.cloud.batch.v1.LifecyclePolicy_Action" json:"action,omitempty"`
	// Conditions that decide why a task failure is dealt with a specific action.
	ActionCondition *LifecyclePolicy_ActionCondition `protobuf:"bytes,2,opt,name=action_condition,json=actionCondition,proto3" json:"action_condition,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LifecyclePolicy) Reset() {
	*x = LifecyclePolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LifecyclePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LifecyclePolicy) ProtoMessage() {}

func (x *LifecyclePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LifecyclePolicy.ProtoReflect.Descriptor instead.
func (*LifecyclePolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{9}
}

func (x *LifecyclePolicy) GetAction() LifecyclePolicy_Action {
	if x != nil {
		return x.Action
	}
	return LifecyclePolicy_ACTION_UNSPECIFIED
}

func (x *LifecyclePolicy) GetActionCondition() *LifecyclePolicy_ActionCondition {
	if x != nil {
		return x.ActionCondition
	}
	return nil
}

// An Environment describes a collection of environment variables to set when
// executing Tasks.
type Environment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A map of environment variable names to values.
	Variables map[string]string `protobuf:"bytes,1,rep,name=variables,proto3" json:"variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of environment variable names to Secret Manager secret names.
	// The VM will access the named secrets to set the value of each environment
	// variable.
	SecretVariables map[string]string `protobuf:"bytes,2,rep,name=secret_variables,json=secretVariables,proto3" json:"secret_variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// An encrypted JSON dictionary where the key/value pairs correspond to
	// environment variable names and their values.
	EncryptedVariables *Environment_KMSEnvMap `protobuf:"bytes,3,opt,name=encrypted_variables,json=encryptedVariables,proto3" json:"encrypted_variables,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Environment) Reset() {
	*x = Environment{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Environment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Environment) ProtoMessage() {}

func (x *Environment) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Environment.ProtoReflect.Descriptor instead.
func (*Environment) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{10}
}

func (x *Environment) GetVariables() map[string]string {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *Environment) GetSecretVariables() map[string]string {
	if x != nil {
		return x.SecretVariables
	}
	return nil
}

func (x *Environment) GetEncryptedVariables() *Environment_KMSEnvMap {
	if x != nil {
		return x.EncryptedVariables
	}
	return nil
}

// The Cloud Batch Job description.
type Job struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. Job name.
	// For example: "projects/123456/locations/us-central1/jobs/job01".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Output only. A system generated unique ID (in UUID4 format) for the Job.
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// Priority of the Job.
	// The valid value range is [0, 100). Default value is 0.
	// Higher value indicates higher priority.
	// A job with higher priority value is more likely to run earlier if all other
	// requirements are satisfied.
	Priority int64 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// Required. TaskGroups in the Job. Only one TaskGroup is supported now.
	TaskGroups []*TaskGroup `protobuf:"bytes,4,rep,name=task_groups,json=taskGroups,proto3" json:"task_groups,omitempty"`
	// Compute resource allocation for all TaskGroups in the Job.
	AllocationPolicy *AllocationPolicy `protobuf:"bytes,7,opt,name=allocation_policy,json=allocationPolicy,proto3" json:"allocation_policy,omitempty"`
	// Labels for the Job. Labels could be user provided or system generated.
	// For example,
	//
	//	"labels": {
	//	   "department": "finance",
	//	   "environment": "test"
	//	 }
	//
	// You can assign up to 64 labels.  [Google Compute Engine label
	// restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
	// apply.
	// Label names that start with "goog-" or "google-" are reserved.
	Labels map[string]string `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. Job status. It is read only for users.
	Status *JobStatus `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	// Output only. When the Job was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. The last time the Job was updated.
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Log preservation policy for the Job.
	LogsPolicy *LogsPolicy `protobuf:"bytes,13,opt,name=logs_policy,json=logsPolicy,proto3" json:"logs_policy,omitempty"`
	// Notification configurations.
	Notifications []*JobNotification `protobuf:"bytes,14,rep,name=notifications,proto3" json:"notifications,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Job) Reset() {
	*x = Job{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Job) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Job) ProtoMessage() {}

func (x *Job) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Job.ProtoReflect.Descriptor instead.
func (*Job) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{11}
}

func (x *Job) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Job) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *Job) GetPriority() int64 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Job) GetTaskGroups() []*TaskGroup {
	if x != nil {
		return x.TaskGroups
	}
	return nil
}

func (x *Job) GetAllocationPolicy() *AllocationPolicy {
	if x != nil {
		return x.AllocationPolicy
	}
	return nil
}

func (x *Job) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Job) GetStatus() *JobStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *Job) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Job) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Job) GetLogsPolicy() *LogsPolicy {
	if x != nil {
		return x.LogsPolicy
	}
	return nil
}

func (x *Job) GetNotifications() []*JobNotification {
	if x != nil {
		return x.Notifications
	}
	return nil
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be
// preserved.
type LogsPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Where logs should be saved.
	Destination LogsPolicy_Destination `protobuf:"varint,1,opt,name=destination,proto3,enum=google.events.cloud.batch.v1.LogsPolicy_Destination" json:"destination,omitempty"`
	// The path to which logs are saved when the destination = PATH. This can be a
	// local file path on the VM, or under the mount point of a Persistent Disk or
	// Filestore, or a Cloud Storage path.
	LogsPath      string `protobuf:"bytes,2,opt,name=logs_path,json=logsPath,proto3" json:"logs_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogsPolicy) Reset() {
	*x = LogsPolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogsPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogsPolicy) ProtoMessage() {}

func (x *LogsPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogsPolicy.ProtoReflect.Descriptor instead.
func (*LogsPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{12}
}

func (x *LogsPolicy) GetDestination() LogsPolicy_Destination {
	if x != nil {
		return x.Destination
	}
	return LogsPolicy_DESTINATION_UNSPECIFIED
}

func (x *LogsPolicy) GetLogsPath() string {
	if x != nil {
		return x.LogsPath
	}
	return ""
}

// Job status.
type JobStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Job state
	State JobStatus_State `protobuf:"varint,1,opt,name=state,proto3,enum=google.events.cloud.batch.v1.JobStatus_State" json:"state,omitempty"`
	// Job status events
	StatusEvents []*StatusEvent `protobuf:"bytes,2,rep,name=status_events,json=statusEvents,proto3" json:"status_events,omitempty"`
	// Aggregated task status for each TaskGroup in the Job.
	// The map key is TaskGroup ID.
	TaskGroups map[string]*JobStatus_TaskGroupStatus `protobuf:"bytes,4,rep,name=task_groups,json=taskGroups,proto3" json:"task_groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The duration of time that the Job spent in status RUNNING.
	RunDuration   *durationpb.Duration `protobuf:"bytes,5,opt,name=run_duration,json=runDuration,proto3" json:"run_duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobStatus) Reset() {
	*x = JobStatus{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobStatus) ProtoMessage() {}

func (x *JobStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobStatus.ProtoReflect.Descriptor instead.
func (*JobStatus) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{13}
}

func (x *JobStatus) GetState() JobStatus_State {
	if x != nil {
		return x.State
	}
	return JobStatus_STATE_UNSPECIFIED
}

func (x *JobStatus) GetStatusEvents() []*StatusEvent {
	if x != nil {
		return x.StatusEvents
	}
	return nil
}

func (x *JobStatus) GetTaskGroups() map[string]*JobStatus_TaskGroupStatus {
	if x != nil {
		return x.TaskGroups
	}
	return nil
}

func (x *JobStatus) GetRunDuration() *durationpb.Duration {
	if x != nil {
		return x.RunDuration
	}
	return nil
}

// Notification configurations.
type JobNotification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Pub/Sub topic where notifications like the job state changes
	// will be published. This topic exist in the same project as the job
	// and billings will be charged to this project.
	// If not specified, no Pub/Sub messages will be sent.
	// Topic format: `projects/{project}/topics/{topic}`.
	PubsubTopic string `protobuf:"bytes,1,opt,name=pubsub_topic,json=pubsubTopic,proto3" json:"pubsub_topic,omitempty"`
	// The attribute requirements of messages to be sent to this Pub/Sub topic.
	// Without this field, no message will be sent.
	Message       *JobNotification_Message `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobNotification) Reset() {
	*x = JobNotification{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobNotification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobNotification) ProtoMessage() {}

func (x *JobNotification) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobNotification.ProtoReflect.Descriptor instead.
func (*JobNotification) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{14}
}

func (x *JobNotification) GetPubsubTopic() string {
	if x != nil {
		return x.PubsubTopic
	}
	return ""
}

func (x *JobNotification) GetMessage() *JobNotification_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

// A Job's resource allocation policy describes when, where, and how compute
// resources should be allocated for the Job.
type AllocationPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Location where compute resources should be allocated for the Job.
	Location *AllocationPolicy_LocationPolicy `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Describe instances that can be created by this AllocationPolicy.
	// Only instances[0] is supported now.
	Instances []*AllocationPolicy_InstancePolicyOrTemplate `protobuf:"bytes,8,rep,name=instances,proto3" json:"instances,omitempty"`
	// Service account that VMs will run as.
	ServiceAccount *ServiceAccount `protobuf:"bytes,9,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty"`
	// Labels applied to all VM instances and other resources
	// created by AllocationPolicy.
	// Labels could be user provided or system generated.
	// You can assign up to 64 labels. [Google Compute Engine label
	// restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
	// apply.
	// Label names that start with "goog-" or "google-" are reserved.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The network policy.
	Network *AllocationPolicy_NetworkPolicy `protobuf:"bytes,7,opt,name=network,proto3" json:"network,omitempty"`
	// The placement policy.
	Placement     *AllocationPolicy_PlacementPolicy `protobuf:"bytes,10,opt,name=placement,proto3" json:"placement,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationPolicy) Reset() {
	*x = AllocationPolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy) ProtoMessage() {}

func (x *AllocationPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy.ProtoReflect.Descriptor instead.
func (*AllocationPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15}
}

func (x *AllocationPolicy) GetLocation() *AllocationPolicy_LocationPolicy {
	if x != nil {
		return x.Location
	}
	return nil
}

func (x *AllocationPolicy) GetInstances() []*AllocationPolicy_InstancePolicyOrTemplate {
	if x != nil {
		return x.Instances
	}
	return nil
}

func (x *AllocationPolicy) GetServiceAccount() *ServiceAccount {
	if x != nil {
		return x.ServiceAccount
	}
	return nil
}

func (x *AllocationPolicy) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *AllocationPolicy) GetNetwork() *AllocationPolicy_NetworkPolicy {
	if x != nil {
		return x.Network
	}
	return nil
}

func (x *AllocationPolicy) GetPlacement() *AllocationPolicy_PlacementPolicy {
	if x != nil {
		return x.Placement
	}
	return nil
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. TaskGroup name.
	// The system generates this field based on parent Job name.
	// For example:
	// "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Required. Tasks in the group share the same task spec.
	TaskSpec *TaskSpec `protobuf:"bytes,3,opt,name=task_spec,json=taskSpec,proto3" json:"task_spec,omitempty"`
	// Number of Tasks in the TaskGroup.
	// Default is 1.
	TaskCount int64 `protobuf:"varint,4,opt,name=task_count,json=taskCount,proto3" json:"task_count,omitempty"`
	// Max number of tasks that can run in parallel.
	// Default to min(task_count, 1000).
	// Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
	Parallelism int64 `protobuf:"varint,5,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	// Scheduling policy for Tasks in the TaskGroup.
	// The default value is AS_SOON_AS_POSSIBLE.
	SchedulingPolicy TaskGroup_SchedulingPolicy `protobuf:"varint,6,opt,name=scheduling_policy,json=schedulingPolicy,proto3,enum=google.events.cloud.batch.v1.TaskGroup_SchedulingPolicy" json:"scheduling_policy,omitempty"`
	// An array of environment variable mappings, which are passed to Tasks with
	// matching indices. If task_environments is used then task_count should
	// not be specified in the request (and will be ignored). Task count will be
	// the length of task_environments.
	//
	// Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in
	// addition to any environment variables set in task_environments, specifying
	// the number of Tasks in the Task's parent TaskGroup, and the specific Task's
	// index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
	TaskEnvironments []*Environment `protobuf:"bytes,9,rep,name=task_environments,json=taskEnvironments,proto3" json:"task_environments,omitempty"`
	// Max number of tasks that can be run on a VM at the same time.
	// If not specified, the system will decide a value based on available
	// compute resources on a VM and task requirements.
	TaskCountPerNode int64 `protobuf:"varint,10,opt,name=task_count_per_node,json=taskCountPerNode,proto3" json:"task_count_per_node,omitempty"`
	// When true, Batch will populate a file with a list of all VMs assigned to
	// the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path
	// of that file. Defaults to false.
	RequireHostsFile bool `protobuf:"varint,11,opt,name=require_hosts_file,json=requireHostsFile,proto3" json:"require_hosts_file,omitempty"`
	// When true, Batch will configure SSH to allow passwordless login between
	// VMs running the Batch tasks in the same TaskGroup.
	PermissiveSsh bool `protobuf:"varint,12,opt,name=permissive_ssh,json=permissiveSsh,proto3" json:"permissive_ssh,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskGroup) Reset() {
	*x = TaskGroup{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskGroup) ProtoMessage() {}

func (x *TaskGroup) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskGroup.ProtoReflect.Descriptor instead.
func (*TaskGroup) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{16}
}

func (x *TaskGroup) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TaskGroup) GetTaskSpec() *TaskSpec {
	if x != nil {
		return x.TaskSpec
	}
	return nil
}

func (x *TaskGroup) GetTaskCount() int64 {
	if x != nil {
		return x.TaskCount
	}
	return 0
}

func (x *TaskGroup) GetParallelism() int64 {
	if x != nil {
		return x.Parallelism
	}
	return 0
}

func (x *TaskGroup) GetSchedulingPolicy() TaskGroup_SchedulingPolicy {
	if x != nil {
		return x.SchedulingPolicy
	}
	return TaskGroup_SCHEDULING_POLICY_UNSPECIFIED
}

func (x *TaskGroup) GetTaskEnvironments() []*Environment {
	if x != nil {
		return x.TaskEnvironments
	}
	return nil
}

func (x *TaskGroup) GetTaskCountPerNode() int64 {
	if x != nil {
		return x.TaskCountPerNode
	}
	return 0
}

func (x *TaskGroup) GetRequireHostsFile() bool {
	if x != nil {
		return x.RequireHostsFile
	}
	return false
}

func (x *TaskGroup) GetPermissiveSsh() bool {
	if x != nil {
		return x.PermissiveSsh
	}
	return false
}

// Carries information about a Google Cloud service account.
type ServiceAccount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Email address of the service account. If not specified, the default
	// Compute Engine service account for the project will be used. If instance
	// template is being used, the service account has to be specified in the
	// instance template and it has to match the email field here.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// List of scopes to be enabled for this service account on the VM, in
	// addition to the cloud-platform API scope that will be added by default.
	Scopes        []string `protobuf:"bytes,2,rep,name=scopes,proto3" json:"scopes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceAccount) Reset() {
	*x = ServiceAccount{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceAccount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceAccount) ProtoMessage() {}

func (x *ServiceAccount) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceAccount.ProtoReflect.Descriptor instead.
func (*ServiceAccount) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{17}
}

func (x *ServiceAccount) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *ServiceAccount) GetScopes() []string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

// The data within all Job events.
type JobEventData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. The Job event payload. Unset for deletion events.
	Payload       *Job `protobuf:"bytes,1,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobEventData) Reset() {
	*x = JobEventData{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobEventData) ProtoMessage() {}

func (x *JobEventData) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobEventData.ProtoReflect.Descriptor instead.
func (*JobEventData) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{18}
}

func (x *JobEventData) GetPayload() *Job {
	if x != nil {
		return x.Payload
	}
	return nil
}

// Container runnable.
type Runnable_Container struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URI to pull the container image from.
	ImageUri string `protobuf:"bytes,1,opt,name=image_uri,json=imageUri,proto3" json:"image_uri,omitempty"`
	// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT
	// (either in the container image or with the entrypoint field below) then
	// commands are appended as arguments to the ENTRYPOINT.
	Commands []string `protobuf:"bytes,2,rep,name=commands,proto3" json:"commands,omitempty"`
	// Overrides the `ENTRYPOINT` specified in the container.
	Entrypoint string `protobuf:"bytes,3,opt,name=entrypoint,proto3" json:"entrypoint,omitempty"`
	// Volumes to mount (bind mount) from the host machine files or directories
	// into the container, formatted to match docker run's --volume option,
	// e.g. /foo:/bar, or /foo:/bar:ro
	Volumes []string `protobuf:"bytes,7,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Arbitrary additional options to include in the "docker run" command when
	// running this container, e.g. "--network host".
	Options string `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// If set to true, external network access to and from container will be
	// blocked, containers that are with block_external_network as true can
	// still communicate with each other, network cannot be specified in the
	// `container.options` field.
	BlockExternalNetwork bool `protobuf:"varint,9,opt,name=block_external_network,json=blockExternalNetwork,proto3" json:"block_external_network,omitempty"`
	// Optional username for logging in to a docker registry. If username
	// matches `projects/*/secrets/*/versions/*` then Batch will read the
	// username from the Secret Manager.
	Username string `protobuf:"bytes,10,opt,name=username,proto3" json:"username,omitempty"`
	// Optional password for logging in to a docker registry. If password
	// matches `projects/*/secrets/*/versions/*` then Batch will read the
	// password from the Secret Manager;
	Password      string `protobuf:"bytes,11,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Runnable_Container) Reset() {
	*x = Runnable_Container{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Runnable_Container) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Runnable_Container) ProtoMessage() {}

func (x *Runnable_Container) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Runnable_Container.ProtoReflect.Descriptor instead.
func (*Runnable_Container) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{7, 0}
}

func (x *Runnable_Container) GetImageUri() string {
	if x != nil {
		return x.ImageUri
	}
	return ""
}

func (x *Runnable_Container) GetCommands() []string {
	if x != nil {
		return x.Commands
	}
	return nil
}

func (x *Runnable_Container) GetEntrypoint() string {
	if x != nil {
		return x.Entrypoint
	}
	return ""
}

func (x *Runnable_Container) GetVolumes() []string {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *Runnable_Container) GetOptions() string {
	if x != nil {
		return x.Options
	}
	return ""
}

func (x *Runnable_Container) GetBlockExternalNetwork() bool {
	if x != nil {
		return x.BlockExternalNetwork
	}
	return false
}

func (x *Runnable_Container) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *Runnable_Container) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

// Script runnable.
type Runnable_Script struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Command:
	//
	//	*Runnable_Script_Path
	//	*Runnable_Script_Text
	Command       isRunnable_Script_Command `protobuf_oneof:"command"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Runnable_Script) Reset() {
	*x = Runnable_Script{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Runnable_Script) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Runnable_Script) ProtoMessage() {}

func (x *Runnable_Script) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Runnable_Script.ProtoReflect.Descriptor instead.
func (*Runnable_Script) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{7, 1}
}

func (x *Runnable_Script) GetCommand() isRunnable_Script_Command {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *Runnable_Script) GetPath() string {
	if x != nil {
		if x, ok := x.Command.(*Runnable_Script_Path); ok {
			return x.Path
		}
	}
	return ""
}

func (x *Runnable_Script) GetText() string {
	if x != nil {
		if x, ok := x.Command.(*Runnable_Script_Text); ok {
			return x.Text
		}
	}
	return ""
}

type isRunnable_Script_Command interface {
	isRunnable_Script_Command()
}

type Runnable_Script_Path struct {
	// Script file path on the host VM.
	//
	// To specify an interpreter, please add a `#!<interpreter>`(also known as
	// [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix))) as the
	// first line of the file.(For example, to execute the script using bash,
	// `#!/bin/bash` should be the first line of the file. To execute the
	// script using`Python3`, `#!/usr/bin/env python3` should be the first
	// line of the file.) Otherwise, the file will by default be excuted by
	// `/bin/sh`.
	Path string `protobuf:"bytes,1,opt,name=path,proto3,oneof"`
}

type Runnable_Script_Text struct {
	// Shell script text.
	//
	// To specify an interpreter, please add a `#!<interpreter>\n` at the
	// beginning of the text.(For example, to execute the script using bash,
	// `#!/bin/bash\n` should be added. To execute the script using`Python3`,
	// `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will
	// by default be excuted by `/bin/sh`.
	Text string `protobuf:"bytes,2,opt,name=text,proto3,oneof"`
}

func (*Runnable_Script_Path) isRunnable_Script_Command() {}

func (*Runnable_Script_Text) isRunnable_Script_Command() {}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type Runnable_Barrier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Barriers are identified by their index in runnable list.
	// Names are not required, but if present should be an identifier.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Runnable_Barrier) Reset() {
	*x = Runnable_Barrier{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Runnable_Barrier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Runnable_Barrier) ProtoMessage() {}

func (x *Runnable_Barrier) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Runnable_Barrier.ProtoReflect.Descriptor instead.
func (*Runnable_Barrier) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{7, 2}
}

func (x *Runnable_Barrier) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Conditions for actions to deal with task failures.
type LifecyclePolicy_ActionCondition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Exit codes of a task execution.
	// If there are more than 1 exit codes,
	// when task executes with any of the exit code in the list,
	// the condition is met and the action will be executed.
	ExitCodes     []int32 `protobuf:"varint,1,rep,packed,name=exit_codes,json=exitCodes,proto3" json:"exit_codes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LifecyclePolicy_ActionCondition) Reset() {
	*x = LifecyclePolicy_ActionCondition{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LifecyclePolicy_ActionCondition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LifecyclePolicy_ActionCondition) ProtoMessage() {}

func (x *LifecyclePolicy_ActionCondition) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LifecyclePolicy_ActionCondition.ProtoReflect.Descriptor instead.
func (*LifecyclePolicy_ActionCondition) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{9, 0}
}

func (x *LifecyclePolicy_ActionCondition) GetExitCodes() []int32 {
	if x != nil {
		return x.ExitCodes
	}
	return nil
}

type Environment_KMSEnvMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the KMS key that will be used to decrypt the cipher text.
	KeyName string `protobuf:"bytes,1,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	// The value of the cipherText response from the `encrypt` method.
	CipherText    string `protobuf:"bytes,2,opt,name=cipher_text,json=cipherText,proto3" json:"cipher_text,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Environment_KMSEnvMap) Reset() {
	*x = Environment_KMSEnvMap{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Environment_KMSEnvMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Environment_KMSEnvMap) ProtoMessage() {}

func (x *Environment_KMSEnvMap) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Environment_KMSEnvMap.ProtoReflect.Descriptor instead.
func (*Environment_KMSEnvMap) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{10, 0}
}

func (x *Environment_KMSEnvMap) GetKeyName() string {
	if x != nil {
		return x.KeyName
	}
	return ""
}

func (x *Environment_KMSEnvMap) GetCipherText() string {
	if x != nil {
		return x.CipherText
	}
	return ""
}

// VM instance status.
type JobStatus_InstanceStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Compute Engine machine type.
	MachineType string `protobuf:"bytes,1,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// The VM instance provisioning model.
	ProvisioningModel AllocationPolicy_ProvisioningModel `protobuf:"varint,2,opt,name=provisioning_model,json=provisioningModel,proto3,enum=google.events.cloud.batch.v1.AllocationPolicy_ProvisioningModel" json:"provisioning_model,omitempty"`
	// The max number of tasks can be assigned to this instance type.
	TaskPack int64 `protobuf:"varint,3,opt,name=task_pack,json=taskPack,proto3" json:"task_pack,omitempty"`
	// The VM boot disk.
	BootDisk      *AllocationPolicy_Disk `protobuf:"bytes,4,opt,name=boot_disk,json=bootDisk,proto3" json:"boot_disk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobStatus_InstanceStatus) Reset() {
	*x = JobStatus_InstanceStatus{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobStatus_InstanceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobStatus_InstanceStatus) ProtoMessage() {}

func (x *JobStatus_InstanceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobStatus_InstanceStatus.ProtoReflect.Descriptor instead.
func (*JobStatus_InstanceStatus) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{13, 0}
}

func (x *JobStatus_InstanceStatus) GetMachineType() string {
	if x != nil {
		return x.MachineType
	}
	return ""
}

func (x *JobStatus_InstanceStatus) GetProvisioningModel() AllocationPolicy_ProvisioningModel {
	if x != nil {
		return x.ProvisioningModel
	}
	return AllocationPolicy_PROVISIONING_MODEL_UNSPECIFIED
}

func (x *JobStatus_InstanceStatus) GetTaskPack() int64 {
	if x != nil {
		return x.TaskPack
	}
	return 0
}

func (x *JobStatus_InstanceStatus) GetBootDisk() *AllocationPolicy_Disk {
	if x != nil {
		return x.BootDisk
	}
	return nil
}

// Aggregated task status for a TaskGroup.
type JobStatus_TaskGroupStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Count of task in each state in the TaskGroup.
	// The map key is task state name.
	Counts map[string]int64 `protobuf:"bytes,1,rep,name=counts,proto3" json:"counts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Status of instances allocated for the TaskGroup.
	Instances     []*JobStatus_InstanceStatus `protobuf:"bytes,2,rep,name=instances,proto3" json:"instances,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobStatus_TaskGroupStatus) Reset() {
	*x = JobStatus_TaskGroupStatus{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobStatus_TaskGroupStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobStatus_TaskGroupStatus) ProtoMessage() {}

func (x *JobStatus_TaskGroupStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobStatus_TaskGroupStatus.ProtoReflect.Descriptor instead.
func (*JobStatus_TaskGroupStatus) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{13, 1}
}

func (x *JobStatus_TaskGroupStatus) GetCounts() map[string]int64 {
	if x != nil {
		return x.Counts
	}
	return nil
}

func (x *JobStatus_TaskGroupStatus) GetInstances() []*JobStatus_InstanceStatus {
	if x != nil {
		return x.Instances
	}
	return nil
}

// Message details.
// Describe the attribute that a message should have.
// Without specified message attributes, no message will be sent by default.
type JobNotification_Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The message type.
	Type JobNotification_Type `protobuf:"varint,1,opt,name=type,proto3,enum=google.events.cloud.batch.v1.JobNotification_Type" json:"type,omitempty"`
	// The new job state.
	NewJobState JobStatus_State `protobuf:"varint,2,opt,name=new_job_state,json=newJobState,proto3,enum=google.events.cloud.batch.v1.JobStatus_State" json:"new_job_state,omitempty"`
	// The new task state.
	NewTaskState  TaskStatus_State `protobuf:"varint,3,opt,name=new_task_state,json=newTaskState,proto3,enum=google.events.cloud.batch.v1.TaskStatus_State" json:"new_task_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobNotification_Message) Reset() {
	*x = JobNotification_Message{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobNotification_Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobNotification_Message) ProtoMessage() {}

func (x *JobNotification_Message) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobNotification_Message.ProtoReflect.Descriptor instead.
func (*JobNotification_Message) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{14, 0}
}

func (x *JobNotification_Message) GetType() JobNotification_Type {
	if x != nil {
		return x.Type
	}
	return JobNotification_TYPE_UNSPECIFIED
}

func (x *JobNotification_Message) GetNewJobState() JobStatus_State {
	if x != nil {
		return x.NewJobState
	}
	return JobStatus_STATE_UNSPECIFIED
}

func (x *JobNotification_Message) GetNewTaskState() TaskStatus_State {
	if x != nil {
		return x.NewTaskState
	}
	return TaskStatus_STATE_UNSPECIFIED
}

type AllocationPolicy_LocationPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of allowed location names represented by internal URLs.
	//
	// Each location can be a region or a zone.
	// Only one region or multiple zones in one region is supported now.
	// For example,
	// ["regions/us-central1"] allow VMs in any zones in region us-central1.
	// ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs
	// in zones us-central1-a and us-central1-c.
	//
	// All locations end up in different regions would cause errors.
	// For example,
	// ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b",
	// "zones/us-west1-a"] contains 2 regions "us-central1" and
	// "us-west1". An error is expected in this case.
	AllowedLocations []string `protobuf:"bytes,1,rep,name=allowed_locations,json=allowedLocations,proto3" json:"allowed_locations,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AllocationPolicy_LocationPolicy) Reset() {
	*x = AllocationPolicy_LocationPolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_LocationPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_LocationPolicy) ProtoMessage() {}

func (x *AllocationPolicy_LocationPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_LocationPolicy.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_LocationPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 0}
}

func (x *AllocationPolicy_LocationPolicy) GetAllowedLocations() []string {
	if x != nil {
		return x.AllowedLocations
	}
	return nil
}

// A new persistent disk or a local ssd.
// A VM can only have one local SSD setting but multiple local SSD partitions.
// See https://cloud.google.com/compute/docs/disks#pdspecs and
// https://cloud.google.com/compute/docs/disks#localssds.
type AllocationPolicy_Disk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A data source from which a PD will be created.
	//
	// Types that are valid to be assigned to DataSource:
	//
	//	*AllocationPolicy_Disk_Image
	//	*AllocationPolicy_Disk_Snapshot
	DataSource isAllocationPolicy_Disk_DataSource `protobuf_oneof:"data_source"`
	// Disk type as shown in `gcloud compute disk-types list`.
	// For example, local SSD uses type "local-ssd".
	// Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd"
	// or "pd-standard".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Disk size in GB.
	//
	// For persistent disk, this field is ignored if `data_source` is `image` or
	// `snapshot`.
	// For local SSD, size_gb should be a multiple of 375GB,
	// otherwise, the final size will be the next greater multiple of 375 GB.
	// For boot disk, Batch will calculate the boot disk size based on source
	// image and task requirements if you do not speicify the size.
	// If both this field and the boot_disk_mib field in task spec's
	// compute_resource are defined, Batch will only honor this field.
	SizeGb int64 `protobuf:"varint,2,opt,name=size_gb,json=sizeGb,proto3" json:"size_gb,omitempty"`
	// Local SSDs are available through both "SCSI" and "NVMe" interfaces.
	// If not indicated, "NVMe" will be the default one for local ssds.
	// We only support "SCSI" for persistent disks now.
	DiskInterface string `protobuf:"bytes,6,opt,name=disk_interface,json=diskInterface,proto3" json:"disk_interface,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationPolicy_Disk) Reset() {
	*x = AllocationPolicy_Disk{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_Disk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_Disk) ProtoMessage() {}

func (x *AllocationPolicy_Disk) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_Disk.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_Disk) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 1}
}

func (x *AllocationPolicy_Disk) GetDataSource() isAllocationPolicy_Disk_DataSource {
	if x != nil {
		return x.DataSource
	}
	return nil
}

func (x *AllocationPolicy_Disk) GetImage() string {
	if x != nil {
		if x, ok := x.DataSource.(*AllocationPolicy_Disk_Image); ok {
			return x.Image
		}
	}
	return ""
}

func (x *AllocationPolicy_Disk) GetSnapshot() string {
	if x != nil {
		if x, ok := x.DataSource.(*AllocationPolicy_Disk_Snapshot); ok {
			return x.Snapshot
		}
	}
	return ""
}

func (x *AllocationPolicy_Disk) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *AllocationPolicy_Disk) GetSizeGb() int64 {
	if x != nil {
		return x.SizeGb
	}
	return 0
}

func (x *AllocationPolicy_Disk) GetDiskInterface() string {
	if x != nil {
		return x.DiskInterface
	}
	return ""
}

type isAllocationPolicy_Disk_DataSource interface {
	isAllocationPolicy_Disk_DataSource()
}

type AllocationPolicy_Disk_Image struct {
	// Name of a public or custom image used as the data source.
	// For example, the following are all valid URLs:
	//
	// * Specify the image by its family name:
	// projects/{project}/global/images/family/{image_family}
	// * Specify the image version:
	// projects/{project}/global/images/{image_version}
	//
	// You can also use Batch customized image in short names.
	// The following image values are supported for a boot disk:
	//
	// * "batch-debian": use Batch Debian images.
	// * "batch-centos": use Batch CentOS images.
	// * "batch-cos": use Batch Container-Optimized images.
	// * "batch-hpc-centos": use Batch HPC CentOS images.
	Image string `protobuf:"bytes,4,opt,name=image,proto3,oneof"`
}

type AllocationPolicy_Disk_Snapshot struct {
	// Name of a snapshot used as the data source.
	// Snapshot is not supported as boot disk now.
	Snapshot string `protobuf:"bytes,5,opt,name=snapshot,proto3,oneof"`
}

func (*AllocationPolicy_Disk_Image) isAllocationPolicy_Disk_DataSource() {}

func (*AllocationPolicy_Disk_Snapshot) isAllocationPolicy_Disk_DataSource() {}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM
// instance.
type AllocationPolicy_AttachedDisk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Attached:
	//
	//	*AllocationPolicy_AttachedDisk_NewDisk
	//	*AllocationPolicy_AttachedDisk_ExistingDisk
	Attached isAllocationPolicy_AttachedDisk_Attached `protobuf_oneof:"attached"`
	// Device name that the guest operating system will see.
	// It is used by Runnable.volumes field to mount disks. So please specify
	// the device_name if you want Batch to help mount the disk, and it should
	// match the device_name field in volumes.
	DeviceName    string `protobuf:"bytes,3,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationPolicy_AttachedDisk) Reset() {
	*x = AllocationPolicy_AttachedDisk{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_AttachedDisk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_AttachedDisk) ProtoMessage() {}

func (x *AllocationPolicy_AttachedDisk) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_AttachedDisk.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_AttachedDisk) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 2}
}

func (x *AllocationPolicy_AttachedDisk) GetAttached() isAllocationPolicy_AttachedDisk_Attached {
	if x != nil {
		return x.Attached
	}
	return nil
}

func (x *AllocationPolicy_AttachedDisk) GetNewDisk() *AllocationPolicy_Disk {
	if x != nil {
		if x, ok := x.Attached.(*AllocationPolicy_AttachedDisk_NewDisk); ok {
			return x.NewDisk
		}
	}
	return nil
}

func (x *AllocationPolicy_AttachedDisk) GetExistingDisk() string {
	if x != nil {
		if x, ok := x.Attached.(*AllocationPolicy_AttachedDisk_ExistingDisk); ok {
			return x.ExistingDisk
		}
	}
	return ""
}

func (x *AllocationPolicy_AttachedDisk) GetDeviceName() string {
	if x != nil {
		return x.DeviceName
	}
	return ""
}

type isAllocationPolicy_AttachedDisk_Attached interface {
	isAllocationPolicy_AttachedDisk_Attached()
}

type AllocationPolicy_AttachedDisk_NewDisk struct {
	NewDisk *AllocationPolicy_Disk `protobuf:"bytes,1,opt,name=new_disk,json=newDisk,proto3,oneof"`
}

type AllocationPolicy_AttachedDisk_ExistingDisk struct {
	// Name of an existing PD.
	ExistingDisk string `protobuf:"bytes,2,opt,name=existing_disk,json=existingDisk,proto3,oneof"`
}

func (*AllocationPolicy_AttachedDisk_NewDisk) isAllocationPolicy_AttachedDisk_Attached() {}

func (*AllocationPolicy_AttachedDisk_ExistingDisk) isAllocationPolicy_AttachedDisk_Attached() {}

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type AllocationPolicy_Accelerator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The accelerator type. For example, "nvidia-tesla-t4".
	// See `gcloud compute accelerator-types list`.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The number of accelerators of this type.
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Deprecated: please use instances[0].install_gpu_drivers instead.
	InstallGpuDrivers bool `protobuf:"varint,3,opt,name=install_gpu_drivers,json=installGpuDrivers,proto3" json:"install_gpu_drivers,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AllocationPolicy_Accelerator) Reset() {
	*x = AllocationPolicy_Accelerator{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_Accelerator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_Accelerator) ProtoMessage() {}

func (x *AllocationPolicy_Accelerator) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_Accelerator.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_Accelerator) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 3}
}

func (x *AllocationPolicy_Accelerator) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *AllocationPolicy_Accelerator) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *AllocationPolicy_Accelerator) GetInstallGpuDrivers() bool {
	if x != nil {
		return x.InstallGpuDrivers
	}
	return false
}

// InstancePolicy describes an instance type and resources attached to each VM
// created by this InstancePolicy.
type AllocationPolicy_InstancePolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Compute Engine machine type.
	MachineType string `protobuf:"bytes,2,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// The minimum CPU platform.
	// See
	// https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
	MinCpuPlatform string `protobuf:"bytes,3,opt,name=min_cpu_platform,json=minCpuPlatform,proto3" json:"min_cpu_platform,omitempty"`
	// The provisioning model.
	ProvisioningModel AllocationPolicy_ProvisioningModel `protobuf:"varint,4,opt,name=provisioning_model,json=provisioningModel,proto3,enum=google.events.cloud.batch.v1.AllocationPolicy_ProvisioningModel" json:"provisioning_model,omitempty"`
	// The accelerators attached to each VM instance.
	Accelerators []*AllocationPolicy_Accelerator `protobuf:"bytes,5,rep,name=accelerators,proto3" json:"accelerators,omitempty"`
	// Boot disk to be created and attached to each VM by this InstancePolicy.
	// Boot disk will be deleted when the VM is deleted.
	// Batch API now only supports booting from image.
	BootDisk *AllocationPolicy_Disk `protobuf:"bytes,8,opt,name=boot_disk,json=bootDisk,proto3" json:"boot_disk,omitempty"`
	// Non-boot disks to be attached for each VM created by this InstancePolicy.
	// New disks will be deleted when the VM is deleted.
	Disks         []*AllocationPolicy_AttachedDisk `protobuf:"bytes,6,rep,name=disks,proto3" json:"disks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationPolicy_InstancePolicy) Reset() {
	*x = AllocationPolicy_InstancePolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_InstancePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_InstancePolicy) ProtoMessage() {}

func (x *AllocationPolicy_InstancePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_InstancePolicy.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_InstancePolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 4}
}

func (x *AllocationPolicy_InstancePolicy) GetMachineType() string {
	if x != nil {
		return x.MachineType
	}
	return ""
}

func (x *AllocationPolicy_InstancePolicy) GetMinCpuPlatform() string {
	if x != nil {
		return x.MinCpuPlatform
	}
	return ""
}

func (x *AllocationPolicy_InstancePolicy) GetProvisioningModel() AllocationPolicy_ProvisioningModel {
	if x != nil {
		return x.ProvisioningModel
	}
	return AllocationPolicy_PROVISIONING_MODEL_UNSPECIFIED
}

func (x *AllocationPolicy_InstancePolicy) GetAccelerators() []*AllocationPolicy_Accelerator {
	if x != nil {
		return x.Accelerators
	}
	return nil
}

func (x *AllocationPolicy_InstancePolicy) GetBootDisk() *AllocationPolicy_Disk {
	if x != nil {
		return x.BootDisk
	}
	return nil
}

func (x *AllocationPolicy_InstancePolicy) GetDisks() []*AllocationPolicy_AttachedDisk {
	if x != nil {
		return x.Disks
	}
	return nil
}

// Either an InstancePolicy or an instance template.
type AllocationPolicy_InstancePolicyOrTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to PolicyTemplate:
	//
	//	*AllocationPolicy_InstancePolicyOrTemplate_Policy
	//	*AllocationPolicy_InstancePolicyOrTemplate_InstanceTemplate
	PolicyTemplate isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate `protobuf_oneof:"policy_template"`
	// Set this field true if users want Batch to help fetch drivers from a
	// third party location and install them for GPUs specified in
	// policy.accelerators or instance_template on their behalf. Default is
	// false.
	InstallGpuDrivers bool `protobuf:"varint,3,opt,name=install_gpu_drivers,json=installGpuDrivers,proto3" json:"install_gpu_drivers,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) Reset() {
	*x = AllocationPolicy_InstancePolicyOrTemplate{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_InstancePolicyOrTemplate) ProtoMessage() {}

func (x *AllocationPolicy_InstancePolicyOrTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_InstancePolicyOrTemplate.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_InstancePolicyOrTemplate) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 5}
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) GetPolicyTemplate() isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate {
	if x != nil {
		return x.PolicyTemplate
	}
	return nil
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) GetPolicy() *AllocationPolicy_InstancePolicy {
	if x != nil {
		if x, ok := x.PolicyTemplate.(*AllocationPolicy_InstancePolicyOrTemplate_Policy); ok {
			return x.Policy
		}
	}
	return nil
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) GetInstanceTemplate() string {
	if x != nil {
		if x, ok := x.PolicyTemplate.(*AllocationPolicy_InstancePolicyOrTemplate_InstanceTemplate); ok {
			return x.InstanceTemplate
		}
	}
	return ""
}

func (x *AllocationPolicy_InstancePolicyOrTemplate) GetInstallGpuDrivers() bool {
	if x != nil {
		return x.InstallGpuDrivers
	}
	return false
}

type isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate interface {
	isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate()
}

type AllocationPolicy_InstancePolicyOrTemplate_Policy struct {
	// InstancePolicy.
	Policy *AllocationPolicy_InstancePolicy `protobuf:"bytes,1,opt,name=policy,proto3,oneof"`
}

type AllocationPolicy_InstancePolicyOrTemplate_InstanceTemplate struct {
	// Name of an instance template used to create VMs.
	// Named the field as 'instance_template' instead of 'template' to avoid
	// c++ keyword conflict.
	InstanceTemplate string `protobuf:"bytes,2,opt,name=instance_template,json=instanceTemplate,proto3,oneof"`
}

func (*AllocationPolicy_InstancePolicyOrTemplate_Policy) isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate() {
}

func (*AllocationPolicy_InstancePolicyOrTemplate_InstanceTemplate) isAllocationPolicy_InstancePolicyOrTemplate_PolicyTemplate() {
}

// A network interface.
type AllocationPolicy_NetworkInterface struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL of an existing network resource.
	// You can specify the network as a full or partial URL.
	//
	// For example, the following are all valid URLs:
	//
	// * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
	// * projects/{project}/global/networks/{network}
	// * global/networks/{network}
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	// The URL of an existing subnetwork resource in the network.
	// You can specify the subnetwork as a full or partial URL.
	//
	// For example, the following are all valid URLs:
	//
	// * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork}
	// * projects/{project}/regions/{region}/subnetworks/{subnetwork}
	// * regions/{region}/subnetworks/{subnetwork}
	Subnetwork string `protobuf:"bytes,2,opt,name=subnetwork,proto3" json:"subnetwork,omitempty"`
	// Default is false (with an external IP address). Required if
	// no external public IP address is attached to the VM. If no external
	// public IP address, additional configuration is required to allow the VM
	// to access Google Services. See
	// https://cloud.google.com/vpc/docs/configure-private-google-access and
	// https://cloud.google.com/nat/docs/gce-example#create-nat for more
	// information.
	NoExternalIpAddress bool `protobuf:"varint,3,opt,name=no_external_ip_address,json=noExternalIpAddress,proto3" json:"no_external_ip_address,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *AllocationPolicy_NetworkInterface) Reset() {
	*x = AllocationPolicy_NetworkInterface{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_NetworkInterface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_NetworkInterface) ProtoMessage() {}

func (x *AllocationPolicy_NetworkInterface) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_NetworkInterface.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_NetworkInterface) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 6}
}

func (x *AllocationPolicy_NetworkInterface) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *AllocationPolicy_NetworkInterface) GetSubnetwork() string {
	if x != nil {
		return x.Subnetwork
	}
	return ""
}

func (x *AllocationPolicy_NetworkInterface) GetNoExternalIpAddress() bool {
	if x != nil {
		return x.NoExternalIpAddress
	}
	return false
}

// NetworkPolicy describes VM instance network configurations.
type AllocationPolicy_NetworkPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Network configurations.
	NetworkInterfaces []*AllocationPolicy_NetworkInterface `protobuf:"bytes,1,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AllocationPolicy_NetworkPolicy) Reset() {
	*x = AllocationPolicy_NetworkPolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_NetworkPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_NetworkPolicy) ProtoMessage() {}

func (x *AllocationPolicy_NetworkPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_NetworkPolicy.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_NetworkPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 7}
}

func (x *AllocationPolicy_NetworkPolicy) GetNetworkInterfaces() []*AllocationPolicy_NetworkInterface {
	if x != nil {
		return x.NetworkInterfaces
	}
	return nil
}

// PlacementPolicy describes a group placement policy for the VMs controlled
// by this AllocationPolicy.
type AllocationPolicy_PlacementPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you
	// want VMs to be located close to each other for low network latency
	// between the VMs. No placement policy will be generated when collocation
	// is UNSPECIFIED.
	Collocation string `protobuf:"bytes,1,opt,name=collocation,proto3" json:"collocation,omitempty"`
	// When specified, causes the job to fail if more than max_distance logical
	// switches are required between VMs. Batch uses the most compact possible
	// placement of VMs even when max_distance is not specified. An explicit
	// max_distance makes that level of compactness a strict requirement.
	// Not yet implemented
	MaxDistance   int64 `protobuf:"varint,2,opt,name=max_distance,json=maxDistance,proto3" json:"max_distance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationPolicy_PlacementPolicy) Reset() {
	*x = AllocationPolicy_PlacementPolicy{}
	mi := &file_cloud_batch_v1_data_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationPolicy_PlacementPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationPolicy_PlacementPolicy) ProtoMessage() {}

func (x *AllocationPolicy_PlacementPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_batch_v1_data_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationPolicy_PlacementPolicy.ProtoReflect.Descriptor instead.
func (*AllocationPolicy_PlacementPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_batch_v1_data_proto_rawDescGZIP(), []int{15, 8}
}

func (x *AllocationPolicy_PlacementPolicy) GetCollocation() string {
	if x != nil {
		return x.Collocation
	}
	return ""
}

func (x *AllocationPolicy_PlacementPolicy) GetMaxDistance() int64 {
	if x != nil {
		return x.MaxDistance
	}
	return 0
}

var File_cloud_batch_v1_data_proto protoreflect.FileDescriptor

const file_cloud_batch_v1_data_proto_rawDesc = "" +
	"\n" +
	"\x19cloud/batch/v1/data.proto\x12\x1cgoogle.events.cloud.batch.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe7\x01\n" +
	"\x06Volume\x125\n" +
	"\x03nfs\x18\x01 \x01(\v2!.google.events.cloud.batch.v1.NFSH\x00R\x03nfs\x125\n" +
	"\x03gcs\x18\x03 \x01(\v2!.google.events.cloud.batch.v1.GCSH\x00R\x03gcs\x12!\n" +
	"\vdevice_name\x18\x06 \x01(\tH\x00R\n" +
	"deviceName\x12\x1d\n" +
	"\n" +
	"mount_path\x18\x04 \x01(\tR\tmountPath\x12#\n" +
	"\rmount_options\x18\x05 \x03(\tR\fmountOptionsB\b\n" +
	"\x06source\">\n" +
	"\x03NFS\x12\x16\n" +
	"\x06server\x18\x01 \x01(\tR\x06server\x12\x1f\n" +
	"\vremote_path\x18\x02 \x01(\tR\n" +
	"remotePath\"&\n" +
	"\x03GCS\x12\x1f\n" +
	"\vremote_path\x18\x01 \x01(\tR\n" +
	"remotePath\"q\n" +
	"\x0fComputeResource\x12\x1b\n" +
	"\tcpu_milli\x18\x01 \x01(\x03R\bcpuMilli\x12\x1d\n" +
	"\n" +
	"memory_mib\x18\x02 \x01(\x03R\tmemoryMib\x12\"\n" +
	"\rboot_disk_mib\x18\x04 \x01(\x03R\vbootDiskMib\"\xa1\x02\n" +
	"\vStatusEvent\x12\x12\n" +
	"\x04type\x18\x03 \x01(\tR\x04type\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x129\n" +
	"\n" +
	"event_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\teventTime\x12R\n" +
	"\x0etask_execution\x18\x04 \x01(\v2+.google.events.cloud.batch.v1.TaskExecutionR\rtaskExecution\x12M\n" +
	"\n" +
	"task_state\x18\x05 \x01(\x0e2..google.events.cloud.batch.v1.TaskStatus.StateR\ttaskState\",\n" +
	"\rTaskExecution\x12\x1b\n" +
	"\texit_code\x18\x01 \x01(\x05R\bexitCode\"\x7f\n" +
	"\n" +
	"TaskStatus\"q\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bASSIGNED\x10\x02\x12\v\n" +
	"\aRUNNING\x10\x03\x12\n" +
	"\n" +
	"\x06FAILED\x10\x04\x12\r\n" +
	"\tSUCCEEDED\x10\x05\x12\x0e\n" +
	"\n" +
	"UNEXECUTED\x10\x06\"\xde\a\n" +
	"\bRunnable\x12P\n" +
	"\tcontainer\x18\x01 \x01(\v20.google.events.cloud.batch.v1.Runnable.ContainerH\x00R\tcontainer\x12G\n" +
	"\x06script\x18\x02 \x01(\v2-.google.events.cloud.batch.v1.Runnable.ScriptH\x00R\x06script\x12J\n" +
	"\abarrier\x18\x06 \x01(\v2..google.events.cloud.batch.v1.Runnable.BarrierH\x00R\abarrier\x12,\n" +
	"\x12ignore_exit_status\x18\x03 \x01(\bR\x10ignoreExitStatus\x12\x1e\n" +
	"\n" +
	"background\x18\x04 \x01(\bR\n" +
	"background\x12\x1d\n" +
	"\n" +
	"always_run\x18\x05 \x01(\bR\talwaysRun\x12K\n" +
	"\venvironment\x18\a \x01(\v2).google.events.cloud.batch.v1.EnvironmentR\venvironment\x123\n" +
	"\atimeout\x18\b \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12J\n" +
	"\x06labels\x18\t \x03(\v22.google.events.cloud.batch.v1.Runnable.LabelsEntryR\x06labels\x1a\x86\x02\n" +
	"\tContainer\x12\x1b\n" +
	"\timage_uri\x18\x01 \x01(\tR\bimageUri\x12\x1a\n" +
	"\bcommands\x18\x02 \x03(\tR\bcommands\x12\x1e\n" +
	"\n" +
	"entrypoint\x18\x03 \x01(\tR\n" +
	"entrypoint\x12\x18\n" +
	"\avolumes\x18\a \x03(\tR\avolumes\x12\x18\n" +
	"\aoptions\x18\b \x01(\tR\aoptions\x124\n" +
	"\x16block_external_network\x18\t \x01(\bR\x14blockExternalNetwork\x12\x1a\n" +
	"\busername\x18\n" +
	" \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\v \x01(\tR\bpassword\x1a?\n" +
	"\x06Script\x12\x14\n" +
	"\x04path\x18\x01 \x01(\tH\x00R\x04path\x12\x14\n" +
	"\x04text\x18\x02 \x01(\tH\x00R\x04textB\t\n" +
	"\acommand\x1a\x1d\n" +
	"\aBarrier\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\f\n" +
	"\n" +
	"executable\"\xa1\x05\n" +
	"\bTaskSpec\x12D\n" +
	"\trunnables\x18\b \x03(\v2&.google.events.cloud.batch.v1.RunnableR\trunnables\x12X\n" +
	"\x10compute_resource\x18\x03 \x01(\v2-.google.events.cloud.batch.v1.ComputeResourceR\x0fcomputeResource\x12C\n" +
	"\x10max_run_duration\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0emaxRunDuration\x12&\n" +
	"\x0fmax_retry_count\x18\x05 \x01(\x05R\rmaxRetryCount\x12\\\n" +
	"\x12lifecycle_policies\x18\t \x03(\v2-.google.events.cloud.batch.v1.LifecyclePolicyR\x11lifecyclePolicies\x12\\\n" +
	"\fenvironments\x18\x06 \x03(\v28.google.events.cloud.batch.v1.TaskSpec.EnvironmentsEntryR\fenvironments\x12>\n" +
	"\avolumes\x18\a \x03(\v2$.google.events.cloud.batch.v1.VolumeR\avolumes\x12K\n" +
	"\venvironment\x18\n" +
	" \x01(\v2).google.events.cloud.batch.v1.EnvironmentR\venvironment\x1a?\n" +
	"\x11EnvironmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xbc\x02\n" +
	"\x0fLifecyclePolicy\x12L\n" +
	"\x06action\x18\x01 \x01(\x0e24.google.events.cloud.batch.v1.LifecyclePolicy.ActionR\x06action\x12h\n" +
	"\x10action_condition\x18\x02 \x01(\v2=.google.events.cloud.batch.v1.LifecyclePolicy.ActionConditionR\x0factionCondition\x1a0\n" +
	"\x0fActionCondition\x12\x1d\n" +
	"\n" +
	"exit_codes\x18\x01 \x03(\x05R\texitCodes\"?\n" +
	"\x06Action\x12\x16\n" +
	"\x12ACTION_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"RETRY_TASK\x10\x01\x12\r\n" +
	"\tFAIL_TASK\x10\x02\"\x81\x04\n" +
	"\vEnvironment\x12V\n" +
	"\tvariables\x18\x01 \x03(\v28.google.events.cloud.batch.v1.Environment.VariablesEntryR\tvariables\x12i\n" +
	"\x10secret_variables\x18\x02 \x03(\v2>.google.events.cloud.batch.v1.Environment.SecretVariablesEntryR\x0fsecretVariables\x12d\n" +
	"\x13encrypted_variables\x18\x03 \x01(\v23.google.events.cloud.batch.v1.Environment.KMSEnvMapR\x12encryptedVariables\x1aG\n" +
	"\tKMSEnvMap\x12\x19\n" +
	"\bkey_name\x18\x01 \x01(\tR\akeyName\x12\x1f\n" +
	"\vcipher_text\x18\x02 \x01(\tR\n" +
	"cipherText\x1a<\n" +
	"\x0eVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aB\n" +
	"\x14SecretVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xcb\x05\n" +
	"\x03Job\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03uid\x18\x02 \x01(\tR\x03uid\x12\x1a\n" +
	"\bpriority\x18\x03 \x01(\x03R\bpriority\x12H\n" +
	"\vtask_groups\x18\x04 \x03(\v2'.google.events.cloud.batch.v1.TaskGroupR\n" +
	"taskGroups\x12[\n" +
	"\x11allocation_policy\x18\a \x01(\v2..google.events.cloud.batch.v1.AllocationPolicyR\x10allocationPolicy\x12E\n" +
	"\x06labels\x18\b \x03(\v2-.google.events.cloud.batch.v1.Job.LabelsEntryR\x06labels\x12?\n" +
	"\x06status\x18\t \x01(\v2'.google.events.cloud.batch.v1.JobStatusR\x06status\x12;\n" +
	"\vcreate_time\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12I\n" +
	"\vlogs_policy\x18\r \x01(\v2(.google.events.cloud.batch.v1.LogsPolicyR\n" +
	"logsPolicy\x12S\n" +
	"\rnotifications\x18\x0e \x03(\v2-.google.events.cloud.batch.v1.JobNotificationR\rnotifications\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xca\x01\n" +
	"\n" +
	"LogsPolicy\x12V\n" +
	"\vdestination\x18\x01 \x01(\x0e24.google.events.cloud.batch.v1.LogsPolicy.DestinationR\vdestination\x12\x1b\n" +
	"\tlogs_path\x18\x02 \x01(\tR\blogsPath\"G\n" +
	"\vDestination\x12\x1b\n" +
	"\x17DESTINATION_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rCLOUD_LOGGING\x10\x01\x12\b\n" +
	"\x04PATH\x10\x02\"\xc5\b\n" +
	"\tJobStatus\x12C\n" +
	"\x05state\x18\x01 \x01(\x0e2-.google.events.cloud.batch.v1.JobStatus.StateR\x05state\x12N\n" +
	"\rstatus_events\x18\x02 \x03(\v2).google.events.cloud.batch.v1.StatusEventR\fstatusEvents\x12X\n" +
	"\vtask_groups\x18\x04 \x03(\v27.google.events.cloud.batch.v1.JobStatus.TaskGroupsEntryR\n" +
	"taskGroups\x12<\n" +
	"\frun_duration\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\vrunDuration\x1a\x93\x02\n" +
	"\x0eInstanceStatus\x12!\n" +
	"\fmachine_type\x18\x01 \x01(\tR\vmachineType\x12o\n" +
	"\x12provisioning_model\x18\x02 \x01(\x0e2@.google.events.cloud.batch.v1.AllocationPolicy.ProvisioningModelR\x11provisioningModel\x12\x1b\n" +
	"\ttask_pack\x18\x03 \x01(\x03R\btaskPack\x12P\n" +
	"\tboot_disk\x18\x04 \x01(\v23.google.events.cloud.batch.v1.AllocationPolicy.DiskR\bbootDisk\x1a\xff\x01\n" +
	"\x0fTaskGroupStatus\x12[\n" +
	"\x06counts\x18\x01 \x03(\v2C.google.events.cloud.batch.v1.JobStatus.TaskGroupStatus.CountsEntryR\x06counts\x12T\n" +
	"\tinstances\x18\x02 \x03(\v26.google.events.cloud.batch.v1.JobStatus.InstanceStatusR\tinstances\x1a9\n" +
	"\vCountsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1av\n" +
	"\x0fTaskGroupsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12M\n" +
	"\x05value\x18\x02 \x01(\v27.google.events.cloud.batch.v1.JobStatus.TaskGroupStatusR\x05value:\x028\x01\"{\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06QUEUED\x10\x01\x12\r\n" +
	"\tSCHEDULED\x10\x02\x12\v\n" +
	"\aRUNNING\x10\x03\x12\r\n" +
	"\tSUCCEEDED\x10\x04\x12\n" +
	"\n" +
	"\x06FAILED\x10\x05\x12\x18\n" +
	"\x14DELETION_IN_PROGRESS\x10\x06\"\xcf\x03\n" +
	"\x0fJobNotification\x12!\n" +
	"\fpubsub_topic\x18\x01 \x01(\tR\vpubsubTopic\x12O\n" +
	"\amessage\x18\x02 \x01(\v25.google.events.cloud.batch.v1.JobNotification.MessageR\amessage\x1a\xfa\x01\n" +
	"\aMessage\x12F\n" +
	"\x04type\x18\x01 \x01(\x0e22.google.events.cloud.batch.v1.JobNotification.TypeR\x04type\x12Q\n" +
	"\rnew_job_state\x18\x02 \x01(\x0e2-.google.events.cloud.batch.v1.JobStatus.StateR\vnewJobState\x12T\n" +
	"\x0enew_task_state\x18\x03 \x01(\x0e2..google.events.cloud.batch.v1.TaskStatus.StateR\fnewTaskState\"K\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11JOB_STATE_CHANGED\x10\x01\x12\x16\n" +
	"\x12TASK_STATE_CHANGED\x10\x02\"\xee\x11\n" +
	"\x10AllocationPolicy\x12Y\n" +
	"\blocation\x18\x01 \x01(\v2=.google.events.cloud.batch.v1.AllocationPolicy.LocationPolicyR\blocation\x12e\n" +
	"\tinstances\x18\b \x03(\v2G.google.events.cloud.batch.v1.AllocationPolicy.InstancePolicyOrTemplateR\tinstances\x12U\n" +
	"\x0fservice_account\x18\t \x01(\v2,.google.events.cloud.batch.v1.ServiceAccountR\x0eserviceAccount\x12R\n" +
	"\x06labels\x18\x06 \x03(\v2:.google.events.cloud.batch.v1.AllocationPolicy.LabelsEntryR\x06labels\x12V\n" +
	"\anetwork\x18\a \x01(\v2<.google.events.cloud.batch.v1.AllocationPolicy.NetworkPolicyR\anetwork\x12\\\n" +
	"\tplacement\x18\n" +
	" \x01(\v2>.google.events.cloud.batch.v1.AllocationPolicy.PlacementPolicyR\tplacement\x1a=\n" +
	"\x0eLocationPolicy\x12+\n" +
	"\x11allowed_locations\x18\x01 \x03(\tR\x10allowedLocations\x1a\x9f\x01\n" +
	"\x04Disk\x12\x16\n" +
	"\x05image\x18\x04 \x01(\tH\x00R\x05image\x12\x1c\n" +
	"\bsnapshot\x18\x05 \x01(\tH\x00R\bsnapshot\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x17\n" +
	"\asize_gb\x18\x02 \x01(\x03R\x06sizeGb\x12%\n" +
	"\x0edisk_interface\x18\x06 \x01(\tR\rdiskInterfaceB\r\n" +
	"\vdata_source\x1a\xb4\x01\n" +
	"\fAttachedDisk\x12P\n" +
	"\bnew_disk\x18\x01 \x01(\v23.google.events.cloud.batch.v1.AllocationPolicy.DiskH\x00R\anewDisk\x12%\n" +
	"\rexisting_disk\x18\x02 \x01(\tH\x00R\fexistingDisk\x12\x1f\n" +
	"\vdevice_name\x18\x03 \x01(\tR\n" +
	"deviceNameB\n" +
	"\n" +
	"\battached\x1ag\n" +
	"\vAccelerator\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x14\n" +
	"\x05count\x18\x02 \x01(\x03R\x05count\x12.\n" +
	"\x13install_gpu_drivers\x18\x03 \x01(\bR\x11installGpuDrivers\x1a\xd3\x03\n" +
	"\x0eInstancePolicy\x12!\n" +
	"\fmachine_type\x18\x02 \x01(\tR\vmachineType\x12(\n" +
	"\x10min_cpu_platform\x18\x03 \x01(\tR\x0eminCpuPlatform\x12o\n" +
	"\x12provisioning_model\x18\x04 \x01(\x0e2@.google.events.cloud.batch.v1.AllocationPolicy.ProvisioningModelR\x11provisioningModel\x12^\n" +
	"\faccelerators\x18\x05 \x03(\v2:.google.events.cloud.batch.v1.AllocationPolicy.AcceleratorR\faccelerators\x12P\n" +
	"\tboot_disk\x18\b \x01(\v23.google.events.cloud.batch.v1.AllocationPolicy.DiskR\bbootDisk\x12Q\n" +
	"\x05disks\x18\x06 \x03(\v2;.google.events.cloud.batch.v1.AllocationPolicy.AttachedDiskR\x05disks\x1a\xe5\x01\n" +
	"\x18InstancePolicyOrTemplate\x12W\n" +
	"\x06policy\x18\x01 \x01(\v2=.google.events.cloud.batch.v1.AllocationPolicy.InstancePolicyH\x00R\x06policy\x12-\n" +
	"\x11instance_template\x18\x02 \x01(\tH\x00R\x10instanceTemplate\x12.\n" +
	"\x13install_gpu_drivers\x18\x03 \x01(\bR\x11installGpuDriversB\x11\n" +
	"\x0fpolicy_template\x1a\x81\x01\n" +
	"\x10NetworkInterface\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12\x1e\n" +
	"\n" +
	"subnetwork\x18\x02 \x01(\tR\n" +
	"subnetwork\x123\n" +
	"\x16no_external_ip_address\x18\x03 \x01(\bR\x13noExternalIpAddress\x1a\x7f\n" +
	"\rNetworkPolicy\x12n\n" +
	"\x12network_interfaces\x18\x01 \x03(\v2?.google.events.cloud.batch.v1.AllocationPolicy.NetworkInterfaceR\x11networkInterfaces\x1aV\n" +
	"\x0fPlacementPolicy\x12 \n" +
	"\vcollocation\x18\x01 \x01(\tR\vcollocation\x12!\n" +
	"\fmax_distance\x18\x02 \x01(\x03R\vmaxDistance\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"`\n" +
	"\x11ProvisioningModel\x12\"\n" +
	"\x1ePROVISIONING_MODEL_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bSTANDARD\x10\x01\x12\b\n" +
	"\x04SPOT\x10\x02\x12\x0f\n" +
	"\vPREEMPTIBLE\x10\x03\"\xc6\x04\n" +
	"\tTaskGroup\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12C\n" +
	"\ttask_spec\x18\x03 \x01(\v2&.google.events.cloud.batch.v1.TaskSpecR\btaskSpec\x12\x1d\n" +
	"\n" +
	"task_count\x18\x04 \x01(\x03R\ttaskCount\x12 \n" +
	"\vparallelism\x18\x05 \x01(\x03R\vparallelism\x12e\n" +
	"\x11scheduling_policy\x18\x06 \x01(\x0e28.google.events.cloud.batch.v1.TaskGroup.SchedulingPolicyR\x10schedulingPolicy\x12V\n" +
	"\x11task_environments\x18\t \x03(\v2).google.events.cloud.batch.v1.EnvironmentR\x10taskEnvironments\x12-\n" +
	"\x13task_count_per_node\x18\n" +
	" \x01(\x03R\x10taskCountPerNode\x12,\n" +
	"\x12require_hosts_file\x18\v \x01(\bR\x10requireHostsFile\x12%\n" +
	"\x0epermissive_ssh\x18\f \x01(\bR\rpermissiveSsh\"\\\n" +
	"\x10SchedulingPolicy\x12!\n" +
	"\x1dSCHEDULING_POLICY_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13AS_SOON_AS_POSSIBLE\x10\x01\x12\f\n" +
	"\bIN_ORDER\x10\x02\">\n" +
	"\x0eServiceAccount\x12\x14\n" +
	"\x05email\x18\x01 \x01(\tR\x05email\x12\x16\n" +
	"\x06scopes\x18\x02 \x03(\tR\x06scopes\"\\\n" +
	"\fJobEventData\x12@\n" +
	"\apayload\x18\x01 \x01(\v2!.google.events.cloud.batch.v1.JobH\x00R\apayload\x88\x01\x01B\n" +
	"\n" +
	"\b_payloadBj\xaa\x02%Google.Events.Protobuf.Cloud.Batch.V1\xca\x02\x1cGoogle\\Events\\Cloud\\Batch\\V1\xea\x02 Google::Events::Cloud::Batch::V1b\x06proto3"

var (
	file_cloud_batch_v1_data_proto_rawDescOnce sync.Once
	file_cloud_batch_v1_data_proto_rawDescData []byte
)

func file_cloud_batch_v1_data_proto_rawDescGZIP() []byte {
	file_cloud_batch_v1_data_proto_rawDescOnce.Do(func() {
		file_cloud_batch_v1_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cloud_batch_v1_data_proto_rawDesc), len(file_cloud_batch_v1_data_proto_rawDesc)))
	})
	return file_cloud_batch_v1_data_proto_rawDescData
}

var file_cloud_batch_v1_data_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_cloud_batch_v1_data_proto_msgTypes = make([]protoimpl.MessageInfo, 44)
var file_cloud_batch_v1_data_proto_goTypes = []any{
	(TaskStatus_State)(0),                   // 0: google.events.cloud.batch.v1.TaskStatus.State
	(LifecyclePolicy_Action)(0),             // 1: google.events.cloud.batch.v1.LifecyclePolicy.Action
	(LogsPolicy_Destination)(0),             // 2: google.events.cloud.batch.v1.LogsPolicy.Destination
	(JobStatus_State)(0),                    // 3: google.events.cloud.batch.v1.JobStatus.State
	(JobNotification_Type)(0),               // 4: google.events.cloud.batch.v1.JobNotification.Type
	(AllocationPolicy_ProvisioningModel)(0), // 5: google.events.cloud.batch.v1.AllocationPolicy.ProvisioningModel
	(TaskGroup_SchedulingPolicy)(0),         // 6: google.events.cloud.batch.v1.TaskGroup.SchedulingPolicy
	(*Volume)(nil),                          // 7: google.events.cloud.batch.v1.Volume
	(*NFS)(nil),                             // 8: google.events.cloud.batch.v1.NFS
	(*GCS)(nil),                             // 9: google.events.cloud.batch.v1.GCS
	(*ComputeResource)(nil),                 // 10: google.events.cloud.batch.v1.ComputeResource
	(*StatusEvent)(nil),                     // 11: google.events.cloud.batch.v1.StatusEvent
	(*TaskExecution)(nil),                   // 12: google.events.cloud.batch.v1.TaskExecution
	(*TaskStatus)(nil),                      // 13: google.events.cloud.batch.v1.TaskStatus
	(*Runnable)(nil),                        // 14: google.events.cloud.batch.v1.Runnable
	(*TaskSpec)(nil),                        // 15: google.events.cloud.batch.v1.TaskSpec
	(*LifecyclePolicy)(nil),                 // 16: google.events.cloud.batch.v1.LifecyclePolicy
	(*Environment)(nil),                     // 17: google.events.cloud.batch.v1.Environment
	(*Job)(nil),                             // 18: google.events.cloud.batch.v1.Job
	(*LogsPolicy)(nil),                      // 19: google.events.cloud.batch.v1.LogsPolicy
	(*JobStatus)(nil),                       // 20: google.events.cloud.batch.v1.JobStatus
	(*JobNotification)(nil),                 // 21: google.events.cloud.batch.v1.JobNotification
	(*AllocationPolicy)(nil),                // 22: google.events.cloud.batch.v1.AllocationPolicy
	(*TaskGroup)(nil),                       // 23: google.events.cloud.batch.v1.TaskGroup
	(*ServiceAccount)(nil),                  // 24: google.events.cloud.batch.v1.ServiceAccount
	(*JobEventData)(nil),                    // 25: google.events.cloud.batch.v1.JobEventData
	(*Runnable_Container)(nil),              // 26: google.events.cloud.batch.v1.Runnable.Container
	(*Runnable_Script)(nil),                 // 27: google.events.cloud.batch.v1.Runnable.Script
	(*Runnable_Barrier)(nil),                // 28: google.events.cloud.batch.v1.Runnable.Barrier
	nil,                                     // 29: google.events.cloud.batch.v1.Runnable.LabelsEntry
	nil,                                     // 30: google.events.cloud.batch.v1.TaskSpec.EnvironmentsEntry
	(*LifecyclePolicy_ActionCondition)(nil), // 31: google.events.cloud.batch.v1.LifecyclePolicy.ActionCondition
	(*Environment_KMSEnvMap)(nil),           // 32: google.events.cloud.batch.v1.Environment.KMSEnvMap
	nil,                                     // 33: google.events.cloud.batch.v1.Environment.VariablesEntry
	nil,                                     // 34: google.events.cloud.batch.v1.Environment.SecretVariablesEntry
	nil,                                     // 35: google.events.cloud.batch.v1.Job.LabelsEntry
	(*JobStatus_InstanceStatus)(nil),        // 36: google.events.cloud.batch.v1.JobStatus.InstanceStatus
	(*JobStatus_TaskGroupStatus)(nil),       // 37: google.events.cloud.batch.v1.JobStatus.TaskGroupStatus
	nil,                                     // 38: google.events.cloud.batch.v1.JobStatus.TaskGroupsEntry
	nil,                                     // 39: google.events.cloud.batch.v1.JobStatus.TaskGroupStatus.CountsEntry
	(*JobNotification_Message)(nil),         // 40: google.events.cloud.batch.v1.JobNotification.Message
	(*AllocationPolicy_LocationPolicy)(nil), // 41: google.events.cloud.batch.v1.AllocationPolicy.LocationPolicy
	(*AllocationPolicy_Disk)(nil),           // 42: google.events.cloud.batch.v1.AllocationPolicy.Disk
	(*AllocationPolicy_AttachedDisk)(nil),   // 43: google.events.cloud.batch.v1.AllocationPolicy.AttachedDisk
	(*AllocationPolicy_Accelerator)(nil),    // 44: google.events.cloud.batch.v1.AllocationPolicy.Accelerator
	(*AllocationPolicy_InstancePolicy)(nil), // 45: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy
	(*AllocationPolicy_InstancePolicyOrTemplate)(nil), // 46: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicyOrTemplate
	(*AllocationPolicy_NetworkInterface)(nil),         // 47: google.events.cloud.batch.v1.AllocationPolicy.NetworkInterface
	(*AllocationPolicy_NetworkPolicy)(nil),            // 48: google.events.cloud.batch.v1.AllocationPolicy.NetworkPolicy
	(*AllocationPolicy_PlacementPolicy)(nil),          // 49: google.events.cloud.batch.v1.AllocationPolicy.PlacementPolicy
	nil,                                               // 50: google.events.cloud.batch.v1.AllocationPolicy.LabelsEntry
	(*timestamppb.Timestamp)(nil),                     // 51: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),                       // 52: google.protobuf.Duration
}
var file_cloud_batch_v1_data_proto_depIdxs = []int32{
	8,  // 0: google.events.cloud.batch.v1.Volume.nfs:type_name -> google.events.cloud.batch.v1.NFS
	9,  // 1: google.events.cloud.batch.v1.Volume.gcs:type_name -> google.events.cloud.batch.v1.GCS
	51, // 2: google.events.cloud.batch.v1.StatusEvent.event_time:type_name -> google.protobuf.Timestamp
	12, // 3: google.events.cloud.batch.v1.StatusEvent.task_execution:type_name -> google.events.cloud.batch.v1.TaskExecution
	0,  // 4: google.events.cloud.batch.v1.StatusEvent.task_state:type_name -> google.events.cloud.batch.v1.TaskStatus.State
	26, // 5: google.events.cloud.batch.v1.Runnable.container:type_name -> google.events.cloud.batch.v1.Runnable.Container
	27, // 6: google.events.cloud.batch.v1.Runnable.script:type_name -> google.events.cloud.batch.v1.Runnable.Script
	28, // 7: google.events.cloud.batch.v1.Runnable.barrier:type_name -> google.events.cloud.batch.v1.Runnable.Barrier
	17, // 8: google.events.cloud.batch.v1.Runnable.environment:type_name -> google.events.cloud.batch.v1.Environment
	52, // 9: google.events.cloud.batch.v1.Runnable.timeout:type_name -> google.protobuf.Duration
	29, // 10: google.events.cloud.batch.v1.Runnable.labels:type_name -> google.events.cloud.batch.v1.Runnable.LabelsEntry
	14, // 11: google.events.cloud.batch.v1.TaskSpec.runnables:type_name -> google.events.cloud.batch.v1.Runnable
	10, // 12: google.events.cloud.batch.v1.TaskSpec.compute_resource:type_name -> google.events.cloud.batch.v1.ComputeResource
	52, // 13: google.events.cloud.batch.v1.TaskSpec.max_run_duration:type_name -> google.protobuf.Duration
	16, // 14: google.events.cloud.batch.v1.TaskSpec.lifecycle_policies:type_name -> google.events.cloud.batch.v1.LifecyclePolicy
	30, // 15: google.events.cloud.batch.v1.TaskSpec.environments:type_name -> google.events.cloud.batch.v1.TaskSpec.EnvironmentsEntry
	7,  // 16: google.events.cloud.batch.v1.TaskSpec.volumes:type_name -> google.events.cloud.batch.v1.Volume
	17, // 17: google.events.cloud.batch.v1.TaskSpec.environment:type_name -> google.events.cloud.batch.v1.Environment
	1,  // 18: google.events.cloud.batch.v1.LifecyclePolicy.action:type_name -> google.events.cloud.batch.v1.LifecyclePolicy.Action
	31, // 19: google.events.cloud.batch.v1.LifecyclePolicy.action_condition:type_name -> google.events.cloud.batch.v1.LifecyclePolicy.ActionCondition
	33, // 20: google.events.cloud.batch.v1.Environment.variables:type_name -> google.events.cloud.batch.v1.Environment.VariablesEntry
	34, // 21: google.events.cloud.batch.v1.Environment.secret_variables:type_name -> google.events.cloud.batch.v1.Environment.SecretVariablesEntry
	32, // 22: google.events.cloud.batch.v1.Environment.encrypted_variables:type_name -> google.events.cloud.batch.v1.Environment.KMSEnvMap
	23, // 23: google.events.cloud.batch.v1.Job.task_groups:type_name -> google.events.cloud.batch.v1.TaskGroup
	22, // 24: google.events.cloud.batch.v1.Job.allocation_policy:type_name -> google.events.cloud.batch.v1.AllocationPolicy
	35, // 25: google.events.cloud.batch.v1.Job.labels:type_name -> google.events.cloud.batch.v1.Job.LabelsEntry
	20, // 26: google.events.cloud.batch.v1.Job.status:type_name -> google.events.cloud.batch.v1.JobStatus
	51, // 27: google.events.cloud.batch.v1.Job.create_time:type_name -> google.protobuf.Timestamp
	51, // 28: google.events.cloud.batch.v1.Job.update_time:type_name -> google.protobuf.Timestamp
	19, // 29: google.events.cloud.batch.v1.Job.logs_policy:type_name -> google.events.cloud.batch.v1.LogsPolicy
	21, // 30: google.events.cloud.batch.v1.Job.notifications:type_name -> google.events.cloud.batch.v1.JobNotification
	2,  // 31: google.events.cloud.batch.v1.LogsPolicy.destination:type_name -> google.events.cloud.batch.v1.LogsPolicy.Destination
	3,  // 32: google.events.cloud.batch.v1.JobStatus.state:type_name -> google.events.cloud.batch.v1.JobStatus.State
	11, // 33: google.events.cloud.batch.v1.JobStatus.status_events:type_name -> google.events.cloud.batch.v1.StatusEvent
	38, // 34: google.events.cloud.batch.v1.JobStatus.task_groups:type_name -> google.events.cloud.batch.v1.JobStatus.TaskGroupsEntry
	52, // 35: google.events.cloud.batch.v1.JobStatus.run_duration:type_name -> google.protobuf.Duration
	40, // 36: google.events.cloud.batch.v1.JobNotification.message:type_name -> google.events.cloud.batch.v1.JobNotification.Message
	41, // 37: google.events.cloud.batch.v1.AllocationPolicy.location:type_name -> google.events.cloud.batch.v1.AllocationPolicy.LocationPolicy
	46, // 38: google.events.cloud.batch.v1.AllocationPolicy.instances:type_name -> google.events.cloud.batch.v1.AllocationPolicy.InstancePolicyOrTemplate
	24, // 39: google.events.cloud.batch.v1.AllocationPolicy.service_account:type_name -> google.events.cloud.batch.v1.ServiceAccount
	50, // 40: google.events.cloud.batch.v1.AllocationPolicy.labels:type_name -> google.events.cloud.batch.v1.AllocationPolicy.LabelsEntry
	48, // 41: google.events.cloud.batch.v1.AllocationPolicy.network:type_name -> google.events.cloud.batch.v1.AllocationPolicy.NetworkPolicy
	49, // 42: google.events.cloud.batch.v1.AllocationPolicy.placement:type_name -> google.events.cloud.batch.v1.AllocationPolicy.PlacementPolicy
	15, // 43: google.events.cloud.batch.v1.TaskGroup.task_spec:type_name -> google.events.cloud.batch.v1.TaskSpec
	6,  // 44: google.events.cloud.batch.v1.TaskGroup.scheduling_policy:type_name -> google.events.cloud.batch.v1.TaskGroup.SchedulingPolicy
	17, // 45: google.events.cloud.batch.v1.TaskGroup.task_environments:type_name -> google.events.cloud.batch.v1.Environment
	18, // 46: google.events.cloud.batch.v1.JobEventData.payload:type_name -> google.events.cloud.batch.v1.Job
	5,  // 47: google.events.cloud.batch.v1.JobStatus.InstanceStatus.provisioning_model:type_name -> google.events.cloud.batch.v1.AllocationPolicy.ProvisioningModel
	42, // 48: google.events.cloud.batch.v1.JobStatus.InstanceStatus.boot_disk:type_name -> google.events.cloud.batch.v1.AllocationPolicy.Disk
	39, // 49: google.events.cloud.batch.v1.JobStatus.TaskGroupStatus.counts:type_name -> google.events.cloud.batch.v1.JobStatus.TaskGroupStatus.CountsEntry
	36, // 50: google.events.cloud.batch.v1.JobStatus.TaskGroupStatus.instances:type_name -> google.events.cloud.batch.v1.JobStatus.InstanceStatus
	37, // 51: google.events.cloud.batch.v1.JobStatus.TaskGroupsEntry.value:type_name -> google.events.cloud.batch.v1.JobStatus.TaskGroupStatus
	4,  // 52: google.events.cloud.batch.v1.JobNotification.Message.type:type_name -> google.events.cloud.batch.v1.JobNotification.Type
	3,  // 53: google.events.cloud.batch.v1.JobNotification.Message.new_job_state:type_name -> google.events.cloud.batch.v1.JobStatus.State
	0,  // 54: google.events.cloud.batch.v1.JobNotification.Message.new_task_state:type_name -> google.events.cloud.batch.v1.TaskStatus.State
	42, // 55: google.events.cloud.batch.v1.AllocationPolicy.AttachedDisk.new_disk:type_name -> google.events.cloud.batch.v1.AllocationPolicy.Disk
	5,  // 56: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy.provisioning_model:type_name -> google.events.cloud.batch.v1.AllocationPolicy.ProvisioningModel
	44, // 57: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy.accelerators:type_name -> google.events.cloud.batch.v1.AllocationPolicy.Accelerator
	42, // 58: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy.boot_disk:type_name -> google.events.cloud.batch.v1.AllocationPolicy.Disk
	43, // 59: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy.disks:type_name -> google.events.cloud.batch.v1.AllocationPolicy.AttachedDisk
	45, // 60: google.events.cloud.batch.v1.AllocationPolicy.InstancePolicyOrTemplate.policy:type_name -> google.events.cloud.batch.v1.AllocationPolicy.InstancePolicy
	47, // 61: google.events.cloud.batch.v1.AllocationPolicy.NetworkPolicy.network_interfaces:type_name -> google.events.cloud.batch.v1.AllocationPolicy.NetworkInterface
	62, // [62:62] is the sub-list for method output_type
	62, // [62:62] is the sub-list for method input_type
	62, // [62:62] is the sub-list for extension type_name
	62, // [62:62] is the sub-list for extension extendee
	0,  // [0:62] is the sub-list for field type_name
}

func init() { file_cloud_batch_v1_data_proto_init() }
func file_cloud_batch_v1_data_proto_init() {
	if File_cloud_batch_v1_data_proto != nil {
		return
	}
	file_cloud_batch_v1_data_proto_msgTypes[0].OneofWrappers = []any{
		(*Volume_Nfs)(nil),
		(*Volume_Gcs)(nil),
		(*Volume_DeviceName)(nil),
	}
	file_cloud_batch_v1_data_proto_msgTypes[7].OneofWrappers = []any{
		(*Runnable_Container_)(nil),
		(*Runnable_Script_)(nil),
		(*Runnable_Barrier_)(nil),
	}
	file_cloud_batch_v1_data_proto_msgTypes[18].OneofWrappers = []any{}
	file_cloud_batch_v1_data_proto_msgTypes[20].OneofWrappers = []any{
		(*Runnable_Script_Path)(nil),
		(*Runnable_Script_Text)(nil),
	}
	file_cloud_batch_v1_data_proto_msgTypes[35].OneofWrappers = []any{
		(*AllocationPolicy_Disk_Image)(nil),
		(*AllocationPolicy_Disk_Snapshot)(nil),
	}
	file_cloud_batch_v1_data_proto_msgTypes[36].OneofWrappers = []any{
		(*AllocationPolicy_AttachedDisk_NewDisk)(nil),
		(*AllocationPolicy_AttachedDisk_ExistingDisk)(nil),
	}
	file_cloud_batch_v1_data_proto_msgTypes[39].OneofWrappers = []any{
		(*AllocationPolicy_InstancePolicyOrTemplate_Policy)(nil),
		(*AllocationPolicy_InstancePolicyOrTemplate_InstanceTemplate)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cloud_batch_v1_data_proto_rawDesc), len(file_cloud_batch_v1_data_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   44,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cloud_batch_v1_data_proto_goTypes,
		DependencyIndexes: file_cloud_batch_v1_data_proto_depIdxs,
		EnumInfos:         file_cloud_batch_v1_data_proto_enumTypes,
		MessageInfos:      file_cloud_batch_v1_data_proto_msgTypes,
	}.Build()
	File_cloud_batch_v1_data_proto = out.File
	file_cloud_batch_v1_data_proto_goTypes = nil
	file_cloud_batch_v1_data_proto_depIdxs = nil
}
