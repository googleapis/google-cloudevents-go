// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v3.21.6
// source: cloud/alloydb/v1/data.proto

package alloydbdata

import (
	dayofweek "google.golang.org/genproto/googleapis/type/dayofweek"
	timeofday "google.golang.org/genproto/googleapis/type/timeofday"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The supported database engine versions.
type DatabaseVersion int32

const (
	// This is an unknown database version.
	DatabaseVersion_DATABASE_VERSION_UNSPECIFIED DatabaseVersion = 0
	// DEPRECATED - The database version is Postgres 13.
	DatabaseVersion_POSTGRES_13 DatabaseVersion = 1
	// The database version is Postgres 14.
	DatabaseVersion_POSTGRES_14 DatabaseVersion = 2
)

// Enum value maps for DatabaseVersion.
var (
	DatabaseVersion_name = map[int32]string{
		0: "DATABASE_VERSION_UNSPECIFIED",
		1: "POSTGRES_13",
		2: "POSTGRES_14",
	}
	DatabaseVersion_value = map[string]int32{
		"DATABASE_VERSION_UNSPECIFIED": 0,
		"POSTGRES_13":                  1,
		"POSTGRES_14":                  2,
	}
)

func (x DatabaseVersion) Enum() *DatabaseVersion {
	p := new(DatabaseVersion)
	*p = x
	return p
}

func (x DatabaseVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DatabaseVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[0].Descriptor()
}

func (DatabaseVersion) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[0]
}

func (x DatabaseVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DatabaseVersion.Descriptor instead.
func (DatabaseVersion) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{0}
}

// Denote the type of migration source that created this cluster.
type MigrationSource_MigrationSourceType int32

const (
	// Migration source is unknown.
	MigrationSource_MIGRATION_SOURCE_TYPE_UNSPECIFIED MigrationSource_MigrationSourceType = 0
	// DMS source means the cluster was created via DMS migration job.
	MigrationSource_DMS MigrationSource_MigrationSourceType = 1
)

// Enum value maps for MigrationSource_MigrationSourceType.
var (
	MigrationSource_MigrationSourceType_name = map[int32]string{
		0: "MIGRATION_SOURCE_TYPE_UNSPECIFIED",
		1: "DMS",
	}
	MigrationSource_MigrationSourceType_value = map[string]int32{
		"MIGRATION_SOURCE_TYPE_UNSPECIFIED": 0,
		"DMS":                               1,
	}
)

func (x MigrationSource_MigrationSourceType) Enum() *MigrationSource_MigrationSourceType {
	p := new(MigrationSource_MigrationSourceType)
	*p = x
	return p
}

func (x MigrationSource_MigrationSourceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MigrationSource_MigrationSourceType) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[1].Descriptor()
}

func (MigrationSource_MigrationSourceType) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[1]
}

func (x MigrationSource_MigrationSourceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MigrationSource_MigrationSourceType.Descriptor instead.
func (MigrationSource_MigrationSourceType) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{1, 0}
}

// Possible encryption types.
type EncryptionInfo_Type int32

const (
	// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
	EncryptionInfo_TYPE_UNSPECIFIED EncryptionInfo_Type = 0
	// The data is encrypted at rest with a key that is fully managed by Google.
	// No key version will be populated. This is the default state.
	EncryptionInfo_GOOGLE_DEFAULT_ENCRYPTION EncryptionInfo_Type = 1
	// The data is encrypted at rest with a key that is managed by the customer.
	// KMS key versions will be populated.
	EncryptionInfo_CUSTOMER_MANAGED_ENCRYPTION EncryptionInfo_Type = 2
)

// Enum value maps for EncryptionInfo_Type.
var (
	EncryptionInfo_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "GOOGLE_DEFAULT_ENCRYPTION",
		2: "CUSTOMER_MANAGED_ENCRYPTION",
	}
	EncryptionInfo_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED":            0,
		"GOOGLE_DEFAULT_ENCRYPTION":   1,
		"CUSTOMER_MANAGED_ENCRYPTION": 2,
	}
)

func (x EncryptionInfo_Type) Enum() *EncryptionInfo_Type {
	p := new(EncryptionInfo_Type)
	*p = x
	return p
}

func (x EncryptionInfo_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionInfo_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[2].Descriptor()
}

func (EncryptionInfo_Type) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[2]
}

func (x EncryptionInfo_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionInfo_Type.Descriptor instead.
func (EncryptionInfo_Type) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{3, 0}
}

// SSL mode options.
type SslConfig_SslMode int32

const (
	// SSL mode not specified. Defaults to SSL_MODE_ALLOW.
	SslConfig_SSL_MODE_UNSPECIFIED SslConfig_SslMode = 0
	// SSL connections are optional. CA verification not enforced.
	SslConfig_SSL_MODE_ALLOW SslConfig_SslMode = 1
	// SSL connections are required. CA verification not enforced.
	// Clients may use locally self-signed certificates (default psql client
	// behavior).
	SslConfig_SSL_MODE_REQUIRE SslConfig_SslMode = 2
	// SSL connections are required. CA verification enforced.
	// Clients must have certificates signed by a Cluster CA, e.g. via
	// GenerateClientCertificate.
	SslConfig_SSL_MODE_VERIFY_CA SslConfig_SslMode = 3
)

// Enum value maps for SslConfig_SslMode.
var (
	SslConfig_SslMode_name = map[int32]string{
		0: "SSL_MODE_UNSPECIFIED",
		1: "SSL_MODE_ALLOW",
		2: "SSL_MODE_REQUIRE",
		3: "SSL_MODE_VERIFY_CA",
	}
	SslConfig_SslMode_value = map[string]int32{
		"SSL_MODE_UNSPECIFIED": 0,
		"SSL_MODE_ALLOW":       1,
		"SSL_MODE_REQUIRE":     2,
		"SSL_MODE_VERIFY_CA":   3,
	}
)

func (x SslConfig_SslMode) Enum() *SslConfig_SslMode {
	p := new(SslConfig_SslMode)
	*p = x
	return p
}

func (x SslConfig_SslMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SslConfig_SslMode) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[3].Descriptor()
}

func (SslConfig_SslMode) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[3]
}

func (x SslConfig_SslMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SslConfig_SslMode.Descriptor instead.
func (SslConfig_SslMode) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{4, 0}
}

// Certificate Authority (CA) source for SSL/TLS certificates.
type SslConfig_CaSource int32

const (
	// Certificate Authority (CA) source not specified. Defaults to
	// CA_SOURCE_MANAGED.
	SslConfig_CA_SOURCE_UNSPECIFIED SslConfig_CaSource = 0
	// Certificate Authority (CA) managed by the AlloyDB Cluster.
	SslConfig_CA_SOURCE_MANAGED SslConfig_CaSource = 1
)

// Enum value maps for SslConfig_CaSource.
var (
	SslConfig_CaSource_name = map[int32]string{
		0: "CA_SOURCE_UNSPECIFIED",
		1: "CA_SOURCE_MANAGED",
	}
	SslConfig_CaSource_value = map[string]int32{
		"CA_SOURCE_UNSPECIFIED": 0,
		"CA_SOURCE_MANAGED":     1,
	}
)

func (x SslConfig_CaSource) Enum() *SslConfig_CaSource {
	p := new(SslConfig_CaSource)
	*p = x
	return p
}

func (x SslConfig_CaSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SslConfig_CaSource) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[4].Descriptor()
}

func (SslConfig_CaSource) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[4]
}

func (x SslConfig_CaSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SslConfig_CaSource.Descriptor instead.
func (SslConfig_CaSource) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{4, 1}
}

// Cluster State
type Cluster_State int32

const (
	// The state of the cluster is unknown.
	Cluster_STATE_UNSPECIFIED Cluster_State = 0
	// The cluster is active and running.
	Cluster_READY Cluster_State = 1
	// The cluster is stopped. All instances in the cluster are stopped.
	// Customers can start a stopped cluster at any point and all their
	// instances will come back to life with same names and IP resources. In
	// this state, customer pays for storage.
	// Associated backups could also be present in a stopped cluster.
	Cluster_STOPPED Cluster_State = 2
	// The cluster is empty and has no associated resources.
	// All instances, associated storage and backups have been deleted.
	Cluster_EMPTY Cluster_State = 3
	// The cluster is being created.
	Cluster_CREATING Cluster_State = 4
	// The cluster is being deleted.
	Cluster_DELETING Cluster_State = 5
	// The creation of the cluster failed.
	Cluster_FAILED Cluster_State = 6
	// The cluster is bootstrapping with data from some other source.
	// Direct mutations to the cluster (e.g. adding read pool) are not allowed.
	Cluster_BOOTSTRAPPING Cluster_State = 7
	// The cluster is under maintenance. AlloyDB regularly performs maintenance
	// and upgrades on customer clusters. Updates on the cluster are
	// not allowed while the cluster is in this state.
	Cluster_MAINTENANCE Cluster_State = 8
	// The cluster is being promoted.
	Cluster_PROMOTING Cluster_State = 9
)

// Enum value maps for Cluster_State.
var (
	Cluster_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "READY",
		2: "STOPPED",
		3: "EMPTY",
		4: "CREATING",
		5: "DELETING",
		6: "FAILED",
		7: "BOOTSTRAPPING",
		8: "MAINTENANCE",
		9: "PROMOTING",
	}
	Cluster_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"READY":             1,
		"STOPPED":           2,
		"EMPTY":             3,
		"CREATING":          4,
		"DELETING":          5,
		"FAILED":            6,
		"BOOTSTRAPPING":     7,
		"MAINTENANCE":       8,
		"PROMOTING":         9,
	}
)

func (x Cluster_State) Enum() *Cluster_State {
	p := new(Cluster_State)
	*p = x
	return p
}

func (x Cluster_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[5].Descriptor()
}

func (Cluster_State) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[5]
}

func (x Cluster_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_State.Descriptor instead.
func (Cluster_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{7, 0}
}

// Type of Cluster
type Cluster_ClusterType int32

const (
	// The type of the cluster is unknown.
	Cluster_CLUSTER_TYPE_UNSPECIFIED Cluster_ClusterType = 0
	// Primary cluster that support read and write operations.
	Cluster_PRIMARY Cluster_ClusterType = 1
	// Secondary cluster that is replicating from another region.
	// This only supports read.
	Cluster_SECONDARY Cluster_ClusterType = 2
)

// Enum value maps for Cluster_ClusterType.
var (
	Cluster_ClusterType_name = map[int32]string{
		0: "CLUSTER_TYPE_UNSPECIFIED",
		1: "PRIMARY",
		2: "SECONDARY",
	}
	Cluster_ClusterType_value = map[string]int32{
		"CLUSTER_TYPE_UNSPECIFIED": 0,
		"PRIMARY":                  1,
		"SECONDARY":                2,
	}
)

func (x Cluster_ClusterType) Enum() *Cluster_ClusterType {
	p := new(Cluster_ClusterType)
	*p = x
	return p
}

func (x Cluster_ClusterType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_ClusterType) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[6].Descriptor()
}

func (Cluster_ClusterType) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[6]
}

func (x Cluster_ClusterType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_ClusterType.Descriptor instead.
func (Cluster_ClusterType) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{7, 1}
}

// Instance State
type Instance_State int32

const (
	// The state of the instance is unknown.
	Instance_STATE_UNSPECIFIED Instance_State = 0
	// The instance is active and running.
	Instance_READY Instance_State = 1
	// The instance is stopped. Instance name and IP resources are preserved.
	Instance_STOPPED Instance_State = 2
	// The instance is being created.
	Instance_CREATING Instance_State = 3
	// The instance is being deleted.
	Instance_DELETING Instance_State = 4
	// The instance is down for maintenance.
	Instance_MAINTENANCE Instance_State = 5
	// The creation of the instance failed or a fatal error occurred during
	// an operation on the instance.
	// Note: Instances in this state would tried to be auto-repaired. And
	// Customers should be able to restart, update or delete these instances.
	Instance_FAILED Instance_State = 6
	// Index 7 is used in the producer apis for ROLLED_BACK state. Keeping that
	// index unused in case that state also needs to exposed via consumer apis
	// in future.
	// The instance has been configured to sync data from some other source.
	Instance_BOOTSTRAPPING Instance_State = 8
	// The instance is being promoted.
	Instance_PROMOTING Instance_State = 9
)

// Enum value maps for Instance_State.
var (
	Instance_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "READY",
		2: "STOPPED",
		3: "CREATING",
		4: "DELETING",
		5: "MAINTENANCE",
		6: "FAILED",
		8: "BOOTSTRAPPING",
		9: "PROMOTING",
	}
	Instance_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"READY":             1,
		"STOPPED":           2,
		"CREATING":          3,
		"DELETING":          4,
		"MAINTENANCE":       5,
		"FAILED":            6,
		"BOOTSTRAPPING":     8,
		"PROMOTING":         9,
	}
)

func (x Instance_State) Enum() *Instance_State {
	p := new(Instance_State)
	*p = x
	return p
}

func (x Instance_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[7].Descriptor()
}

func (Instance_State) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[7]
}

func (x Instance_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_State.Descriptor instead.
func (Instance_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 0}
}

// Type of an Instance
type Instance_InstanceType int32

const (
	// The type of the instance is unknown.
	Instance_INSTANCE_TYPE_UNSPECIFIED Instance_InstanceType = 0
	// PRIMARY instances support read and write operations.
	Instance_PRIMARY Instance_InstanceType = 1
	// READ POOL instances support read operations only. Each read pool instance
	// consists of one or more homogeneous nodes.
	//   - Read pool of size 1 can only have zonal availability.
	//   - Read pools with node count of 2 or more can have regional
	//     availability (nodes are present in 2 or more zones in a region).
	Instance_READ_POOL Instance_InstanceType = 2
	// SECONDARY instances support read operations only. SECONDARY instance
	// is a cross-region read replica
	Instance_SECONDARY Instance_InstanceType = 3
)

// Enum value maps for Instance_InstanceType.
var (
	Instance_InstanceType_name = map[int32]string{
		0: "INSTANCE_TYPE_UNSPECIFIED",
		1: "PRIMARY",
		2: "READ_POOL",
		3: "SECONDARY",
	}
	Instance_InstanceType_value = map[string]int32{
		"INSTANCE_TYPE_UNSPECIFIED": 0,
		"PRIMARY":                   1,
		"READ_POOL":                 2,
		"SECONDARY":                 3,
	}
)

func (x Instance_InstanceType) Enum() *Instance_InstanceType {
	p := new(Instance_InstanceType)
	*p = x
	return p
}

func (x Instance_InstanceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_InstanceType) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[8].Descriptor()
}

func (Instance_InstanceType) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[8]
}

func (x Instance_InstanceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_InstanceType.Descriptor instead.
func (Instance_InstanceType) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 1}
}

// The Availability type of an instance. Potential values:
// - ZONAL: The instance serves data from only one zone. Outages in that
// zone affect instance availability.
// - REGIONAL: The instance can serve data from more than one zone in a
// region (it is highly available).
type Instance_AvailabilityType int32

const (
	// This is an unknown Availability type.
	Instance_AVAILABILITY_TYPE_UNSPECIFIED Instance_AvailabilityType = 0
	// Zonal available instance.
	Instance_ZONAL Instance_AvailabilityType = 1
	// Regional (or Highly) available instance.
	Instance_REGIONAL Instance_AvailabilityType = 2
)

// Enum value maps for Instance_AvailabilityType.
var (
	Instance_AvailabilityType_name = map[int32]string{
		0: "AVAILABILITY_TYPE_UNSPECIFIED",
		1: "ZONAL",
		2: "REGIONAL",
	}
	Instance_AvailabilityType_value = map[string]int32{
		"AVAILABILITY_TYPE_UNSPECIFIED": 0,
		"ZONAL":                         1,
		"REGIONAL":                      2,
	}
)

func (x Instance_AvailabilityType) Enum() *Instance_AvailabilityType {
	p := new(Instance_AvailabilityType)
	*p = x
	return p
}

func (x Instance_AvailabilityType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_AvailabilityType) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[9].Descriptor()
}

func (Instance_AvailabilityType) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[9]
}

func (x Instance_AvailabilityType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_AvailabilityType.Descriptor instead.
func (Instance_AvailabilityType) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 2}
}

// Backup State
type Backup_State int32

const (
	// The state of the backup is unknown.
	Backup_STATE_UNSPECIFIED Backup_State = 0
	// The backup is ready.
	Backup_READY Backup_State = 1
	// The backup is creating.
	Backup_CREATING Backup_State = 2
	// The backup failed.
	Backup_FAILED Backup_State = 3
	// The backup is being deleted.
	Backup_DELETING Backup_State = 4
)

// Enum value maps for Backup_State.
var (
	Backup_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "READY",
		2: "CREATING",
		3: "FAILED",
		4: "DELETING",
	}
	Backup_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"READY":             1,
		"CREATING":          2,
		"FAILED":            3,
		"DELETING":          4,
	}
)

func (x Backup_State) Enum() *Backup_State {
	p := new(Backup_State)
	*p = x
	return p
}

func (x Backup_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Backup_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[10].Descriptor()
}

func (Backup_State) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[10]
}

func (x Backup_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Backup_State.Descriptor instead.
func (Backup_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{9, 0}
}

// Backup Type
type Backup_Type int32

const (
	// Backup Type is unknown.
	Backup_TYPE_UNSPECIFIED Backup_Type = 0
	// ON_DEMAND backups that were triggered by the customer (e.g., not
	// AUTOMATED).
	Backup_ON_DEMAND Backup_Type = 1
	// AUTOMATED backups triggered by the automated backups scheduler pursuant
	// to an automated backup policy.
	Backup_AUTOMATED Backup_Type = 2
	// CONTINUOUS backups triggered by the automated backups scheduler
	// due to a continuous backup policy.
	Backup_CONTINUOUS Backup_Type = 3
)

// Enum value maps for Backup_Type.
var (
	Backup_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "ON_DEMAND",
		2: "AUTOMATED",
		3: "CONTINUOUS",
	}
	Backup_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"ON_DEMAND":        1,
		"AUTOMATED":        2,
		"CONTINUOUS":       3,
	}
)

func (x Backup_Type) Enum() *Backup_Type {
	p := new(Backup_Type)
	*p = x
	return p
}

func (x Backup_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Backup_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_alloydb_v1_data_proto_enumTypes[11].Descriptor()
}

func (Backup_Type) Type() protoreflect.EnumType {
	return &file_cloud_alloydb_v1_data_proto_enumTypes[11]
}

func (x Backup_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Backup_Type.Descriptor instead.
func (Backup_Type) EnumDescriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{9, 1}
}

// The username/password for a database user. Used for specifying initial
// users at cluster creation time.
type UserPassword struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The database username.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// The initial password for the user.
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserPassword) Reset() {
	*x = UserPassword{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserPassword) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserPassword) ProtoMessage() {}

func (x *UserPassword) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserPassword.ProtoReflect.Descriptor instead.
func (*UserPassword) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{0}
}

func (x *UserPassword) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *UserPassword) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

// Subset of the source instance configuration that is available when reading
// the cluster resource.
type MigrationSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The host and port of the on-premises instance in host:port
	// format
	HostPort string `protobuf:"bytes,1,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	// Output only. Place holder for the external source identifier(e.g DMS job
	// name) that created the cluster.
	ReferenceId string `protobuf:"bytes,2,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	// Output only. Type of migration source.
	SourceType    MigrationSource_MigrationSourceType `protobuf:"varint,3,opt,name=source_type,json=sourceType,proto3,enum=google.events.cloud.alloydb.v1.MigrationSource_MigrationSourceType" json:"source_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MigrationSource) Reset() {
	*x = MigrationSource{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MigrationSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrationSource) ProtoMessage() {}

func (x *MigrationSource) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MigrationSource.ProtoReflect.Descriptor instead.
func (*MigrationSource) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{1}
}

func (x *MigrationSource) GetHostPort() string {
	if x != nil {
		return x.HostPort
	}
	return ""
}

func (x *MigrationSource) GetReferenceId() string {
	if x != nil {
		return x.ReferenceId
	}
	return ""
}

func (x *MigrationSource) GetSourceType() MigrationSource_MigrationSourceType {
	if x != nil {
		return x.SourceType
	}
	return MigrationSource_MIGRATION_SOURCE_TYPE_UNSPECIFIED
}

// EncryptionConfig describes the encryption config of a cluster or a backup
// that is encrypted with a CMEK (customer-managed encryption key).
type EncryptionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The fully-qualified resource name of the KMS key.
	// Each Cloud KMS key is regionalized and has the following format:
	// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
	KmsKeyName    string `protobuf:"bytes,1,opt,name=kms_key_name,json=kmsKeyName,proto3" json:"kms_key_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptionConfig) Reset() {
	*x = EncryptionConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionConfig) ProtoMessage() {}

func (x *EncryptionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionConfig.ProtoReflect.Descriptor instead.
func (*EncryptionConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{2}
}

func (x *EncryptionConfig) GetKmsKeyName() string {
	if x != nil {
		return x.KmsKeyName
	}
	return ""
}

// EncryptionInfo describes the encryption information of a cluster or a backup.
type EncryptionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. Type of encryption.
	EncryptionType EncryptionInfo_Type `protobuf:"varint,1,opt,name=encryption_type,json=encryptionType,proto3,enum=google.events.cloud.alloydb.v1.EncryptionInfo_Type" json:"encryption_type,omitempty"`
	// Output only. Cloud KMS key versions that are being used to protect the
	// database or the backup.
	KmsKeyVersions []string `protobuf:"bytes,2,rep,name=kms_key_versions,json=kmsKeyVersions,proto3" json:"kms_key_versions,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *EncryptionInfo) Reset() {
	*x = EncryptionInfo{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionInfo) ProtoMessage() {}

func (x *EncryptionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionInfo.ProtoReflect.Descriptor instead.
func (*EncryptionInfo) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{3}
}

func (x *EncryptionInfo) GetEncryptionType() EncryptionInfo_Type {
	if x != nil {
		return x.EncryptionType
	}
	return EncryptionInfo_TYPE_UNSPECIFIED
}

func (x *EncryptionInfo) GetKmsKeyVersions() []string {
	if x != nil {
		return x.KmsKeyVersions
	}
	return nil
}

// SSL configuration for an AlloyDB Cluster.
type SslConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
	SslMode SslConfig_SslMode `protobuf:"varint,1,opt,name=ssl_mode,json=sslMode,proto3,enum=google.events.cloud.alloydb.v1.SslConfig_SslMode" json:"ssl_mode,omitempty"`
	// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is
	// supported currently, and is the default value.
	CaSource      SslConfig_CaSource `protobuf:"varint,2,opt,name=ca_source,json=caSource,proto3,enum=google.events.cloud.alloydb.v1.SslConfig_CaSource" json:"ca_source,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SslConfig) Reset() {
	*x = SslConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SslConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SslConfig) ProtoMessage() {}

func (x *SslConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SslConfig.ProtoReflect.Descriptor instead.
func (*SslConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{4}
}

func (x *SslConfig) GetSslMode() SslConfig_SslMode {
	if x != nil {
		return x.SslMode
	}
	return SslConfig_SSL_MODE_UNSPECIFIED
}

func (x *SslConfig) GetCaSource() SslConfig_CaSource {
	if x != nil {
		return x.CaSource
	}
	return SslConfig_CA_SOURCE_UNSPECIFIED
}

// Message describing the user-specified automated backup policy.
//
// All fields in the automated backup policy are optional. Defaults for each
// field are provided if they are not set.
type AutomatedBackupPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The schedule for this automated backup policy.
	//
	// A schedule specifies times at which to start a backup. If a backup
	// window is also provided, the backup is guaranteed to be started and
	// completed within the start time plus the backup window. If the backup is
	// not completed within the backup window it is marked as failed.
	//
	// If not set, the schedule defaults to a weekly schedule with one backup
	// per day and a start time chosen arbitrarily.
	//
	// Types that are valid to be assigned to Schedule:
	//
	//	*AutomatedBackupPolicy_WeeklySchedule_
	Schedule isAutomatedBackupPolicy_Schedule `protobuf_oneof:"schedule"`
	// The retention policy for automated backups.
	//
	// The retention policy for a backup is fixed at the time the backup is
	// created. Changes to this field only apply to new backups taken with the
	// policy; the retentions of existing backups remain unchanged.
	//
	// If no retention policy is set, a default of 14 days is used.
	//
	// Types that are valid to be assigned to Retention:
	//
	//	*AutomatedBackupPolicy_TimeBasedRetention_
	//	*AutomatedBackupPolicy_QuantityBasedRetention_
	Retention isAutomatedBackupPolicy_Retention `protobuf_oneof:"retention"`
	// Whether automated automated backups are enabled. If not set, defaults to
	// true.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled,proto3,oneof" json:"enabled,omitempty"`
	// The length of the time window during which a backup can be
	// taken. If a backup does not succeed within this time window, it will be
	// canceled and considered failed.
	//
	// The backup window must be at least 5 minutes long. There is no upper bound
	// on the window. If not set, it defaults to 1 hour.
	BackupWindow *durationpb.Duration `protobuf:"bytes,3,opt,name=backup_window,json=backupWindow,proto3" json:"backup_window,omitempty"`
	// Optional. The encryption config can be specified to encrypt the
	// backups with a customer-managed encryption key (CMEK). When this field is
	// not specified, the backup will then use default encryption scheme to
	// protect the user data.
	EncryptionConfig *EncryptionConfig `protobuf:"bytes,8,opt,name=encryption_config,json=encryptionConfig,proto3" json:"encryption_config,omitempty"`
	// The location where the backup will be stored. Currently, the only supported
	// option is to store the backup in the same region as the cluster.
	//
	// If empty, defaults to the region of the cluster.
	Location string `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	// Labels to apply to backups created using this configuration.
	Labels        map[string]string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomatedBackupPolicy) Reset() {
	*x = AutomatedBackupPolicy{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomatedBackupPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatedBackupPolicy) ProtoMessage() {}

func (x *AutomatedBackupPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatedBackupPolicy.ProtoReflect.Descriptor instead.
func (*AutomatedBackupPolicy) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{5}
}

func (x *AutomatedBackupPolicy) GetSchedule() isAutomatedBackupPolicy_Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetWeeklySchedule() *AutomatedBackupPolicy_WeeklySchedule {
	if x != nil {
		if x, ok := x.Schedule.(*AutomatedBackupPolicy_WeeklySchedule_); ok {
			return x.WeeklySchedule
		}
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetRetention() isAutomatedBackupPolicy_Retention {
	if x != nil {
		return x.Retention
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetTimeBasedRetention() *AutomatedBackupPolicy_TimeBasedRetention {
	if x != nil {
		if x, ok := x.Retention.(*AutomatedBackupPolicy_TimeBasedRetention_); ok {
			return x.TimeBasedRetention
		}
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetQuantityBasedRetention() *AutomatedBackupPolicy_QuantityBasedRetention {
	if x != nil {
		if x, ok := x.Retention.(*AutomatedBackupPolicy_QuantityBasedRetention_); ok {
			return x.QuantityBasedRetention
		}
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *AutomatedBackupPolicy) GetBackupWindow() *durationpb.Duration {
	if x != nil {
		return x.BackupWindow
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetEncryptionConfig() *EncryptionConfig {
	if x != nil {
		return x.EncryptionConfig
	}
	return nil
}

func (x *AutomatedBackupPolicy) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *AutomatedBackupPolicy) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

type isAutomatedBackupPolicy_Schedule interface {
	isAutomatedBackupPolicy_Schedule()
}

type AutomatedBackupPolicy_WeeklySchedule_ struct {
	// Weekly schedule for the Backup.
	WeeklySchedule *AutomatedBackupPolicy_WeeklySchedule `protobuf:"bytes,2,opt,name=weekly_schedule,json=weeklySchedule,proto3,oneof"`
}

func (*AutomatedBackupPolicy_WeeklySchedule_) isAutomatedBackupPolicy_Schedule() {}

type isAutomatedBackupPolicy_Retention interface {
	isAutomatedBackupPolicy_Retention()
}

type AutomatedBackupPolicy_TimeBasedRetention_ struct {
	// Time-based Backup retention policy.
	TimeBasedRetention *AutomatedBackupPolicy_TimeBasedRetention `protobuf:"bytes,4,opt,name=time_based_retention,json=timeBasedRetention,proto3,oneof"`
}

type AutomatedBackupPolicy_QuantityBasedRetention_ struct {
	// Quantity-based Backup retention policy to retain recent backups.
	QuantityBasedRetention *AutomatedBackupPolicy_QuantityBasedRetention `protobuf:"bytes,5,opt,name=quantity_based_retention,json=quantityBasedRetention,proto3,oneof"`
}

func (*AutomatedBackupPolicy_TimeBasedRetention_) isAutomatedBackupPolicy_Retention() {}

func (*AutomatedBackupPolicy_QuantityBasedRetention_) isAutomatedBackupPolicy_Retention() {}

// Message describing a BackupSource.
type BackupSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The system-generated UID of the backup which was used to
	// create this resource. The UID is generated when the backup is created, and
	// it is retained until the backup is deleted.
	BackupUid string `protobuf:"bytes,2,opt,name=backup_uid,json=backupUid,proto3" json:"backup_uid,omitempty"`
	// Required. The name of the backup resource with the format:
	//   - projects/{project}/locations/{region}/backups/{backup_id}
	BackupName    string `protobuf:"bytes,1,opt,name=backup_name,json=backupName,proto3" json:"backup_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupSource) Reset() {
	*x = BackupSource{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupSource) ProtoMessage() {}

func (x *BackupSource) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupSource.ProtoReflect.Descriptor instead.
func (*BackupSource) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{6}
}

func (x *BackupSource) GetBackupUid() string {
	if x != nil {
		return x.BackupUid
	}
	return ""
}

func (x *BackupSource) GetBackupName() string {
	if x != nil {
		return x.BackupName
	}
	return ""
}

// A cluster is a collection of regional AlloyDB resources. It can include a
// primary instance and one or more read pool instances.
// All cluster resources share a storage layer, which scales as needed.
type Cluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// In case of an imported cluster, this field contains information about the
	// source this cluster was imported from.
	//
	// Types that are valid to be assigned to Source:
	//
	//	*Cluster_BackupSource
	//	*Cluster_MigrationSource
	Source isCluster_Source `protobuf_oneof:"source"`
	// Output only. The name of the cluster resource with the format:
	//   - projects/{project}/locations/{region}/clusters/{cluster_id}
	//
	// where the cluster ID segment should satisfy the regex expression
	// `[a-z0-9-]+`. For more details see https://google.aip.dev/122.
	// The prefix of the cluster resource name is the name of the parent resource:
	//   - projects/{project}/locations/{region}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// User-settable and human-readable display name for the Cluster.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Output only. The system-generated UID of the resource. The UID is assigned
	// when the resource is created, and it is retained until it is deleted.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// Output only. Create time stamp
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. Update time stamp
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Output only. Delete time stamp
	DeleteTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=delete_time,json=deleteTime,proto3" json:"delete_time,omitempty"`
	// Labels as key value pairs
	Labels map[string]string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. The current serving state of the cluster.
	State Cluster_State `protobuf:"varint,8,opt,name=state,proto3,enum=google.events.cloud.alloydb.v1.Cluster_State" json:"state,omitempty"`
	// Output only. The type of the cluster. This is an output-only field and it's
	// populated at the Cluster creation time or the Cluster promotion
	// time. The cluster type is determined by which RPC was used to create
	// the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster`
	ClusterType Cluster_ClusterType `protobuf:"varint,24,opt,name=cluster_type,json=clusterType,proto3,enum=google.events.cloud.alloydb.v1.Cluster_ClusterType" json:"cluster_type,omitempty"`
	// Output only. The database engine major version. This is an output-only
	// field and it's populated at the Cluster creation time. This field cannot be
	// changed after cluster creation.
	DatabaseVersion DatabaseVersion `protobuf:"varint,9,opt,name=database_version,json=databaseVersion,proto3,enum=google.events.cloud.alloydb.v1.DatabaseVersion" json:"database_version,omitempty"`
	// Required. The resource link for the VPC network in which cluster resources
	// are created and from which they are accessible via Private IP. The network
	// must belong to the same project as the cluster. It is specified in the
	// form: "projects/{project_number}/global/networks/{network_id}". This is
	// required to create a cluster. It can be updated, but it cannot be removed.
	Network string `protobuf:"bytes,10,opt,name=network,proto3" json:"network,omitempty"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag string `protobuf:"bytes,11,opt,name=etag,proto3" json:"etag,omitempty"`
	// Annotations to allow client tools to store small amount of arbitrary data.
	// This is distinct from labels.
	// https://google.aip.dev/128
	Annotations map[string]string `protobuf:"bytes,12,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Cluster does not match the user's
	// intended state, and the service is actively updating the resource to
	// reconcile them. This can happen due to user-triggered updates or
	// system actions like failover or maintenance.
	Reconciling bool `protobuf:"varint,13,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	// The automated backup policy for this cluster.
	//
	// If no policy is provided then the default policy will be used. If backups
	// are supported for the cluster, the default policy takes one backup a day,
	// has a backup window of 1 hour, and retains backups for 14 days.
	// For more information on the defaults, consult the
	// documentation for the message type.
	AutomatedBackupPolicy *AutomatedBackupPolicy `protobuf:"bytes,17,opt,name=automated_backup_policy,json=automatedBackupPolicy,proto3" json:"automated_backup_policy,omitempty"`
	// SSL configuration for this AlloyDB Cluster.
	SslConfig *SslConfig `protobuf:"bytes,18,opt,name=ssl_config,json=sslConfig,proto3" json:"ssl_config,omitempty"`
	// Optional. The encryption config can be specified to encrypt the data disks
	// and other persistent data resources of a cluster with a
	// customer-managed encryption key (CMEK). When this field is not
	// specified, the cluster will then use default encryption scheme to
	// protect the user data.
	EncryptionConfig *EncryptionConfig `protobuf:"bytes,19,opt,name=encryption_config,json=encryptionConfig,proto3" json:"encryption_config,omitempty"`
	// Output only. The encryption information for the cluster.
	EncryptionInfo *EncryptionInfo `protobuf:"bytes,20,opt,name=encryption_info,json=encryptionInfo,proto3" json:"encryption_info,omitempty"`
	// Cross Region replication config specific to SECONDARY cluster.
	SecondaryConfig *Cluster_SecondaryConfig `protobuf:"bytes,22,opt,name=secondary_config,json=secondaryConfig,proto3" json:"secondary_config,omitempty"`
	// Output only. Cross Region replication config specific to PRIMARY cluster.
	PrimaryConfig *Cluster_PrimaryConfig `protobuf:"bytes,23,opt,name=primary_config,json=primaryConfig,proto3" json:"primary_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster) Reset() {
	*x = Cluster{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster) ProtoMessage() {}

func (x *Cluster) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster.ProtoReflect.Descriptor instead.
func (*Cluster) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{7}
}

func (x *Cluster) GetSource() isCluster_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Cluster) GetBackupSource() *BackupSource {
	if x != nil {
		if x, ok := x.Source.(*Cluster_BackupSource); ok {
			return x.BackupSource
		}
	}
	return nil
}

func (x *Cluster) GetMigrationSource() *MigrationSource {
	if x != nil {
		if x, ok := x.Source.(*Cluster_MigrationSource); ok {
			return x.MigrationSource
		}
	}
	return nil
}

func (x *Cluster) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cluster) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *Cluster) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *Cluster) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Cluster) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Cluster) GetDeleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.DeleteTime
	}
	return nil
}

func (x *Cluster) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Cluster) GetState() Cluster_State {
	if x != nil {
		return x.State
	}
	return Cluster_STATE_UNSPECIFIED
}

func (x *Cluster) GetClusterType() Cluster_ClusterType {
	if x != nil {
		return x.ClusterType
	}
	return Cluster_CLUSTER_TYPE_UNSPECIFIED
}

func (x *Cluster) GetDatabaseVersion() DatabaseVersion {
	if x != nil {
		return x.DatabaseVersion
	}
	return DatabaseVersion_DATABASE_VERSION_UNSPECIFIED
}

func (x *Cluster) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *Cluster) GetEtag() string {
	if x != nil {
		return x.Etag
	}
	return ""
}

func (x *Cluster) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *Cluster) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

func (x *Cluster) GetAutomatedBackupPolicy() *AutomatedBackupPolicy {
	if x != nil {
		return x.AutomatedBackupPolicy
	}
	return nil
}

func (x *Cluster) GetSslConfig() *SslConfig {
	if x != nil {
		return x.SslConfig
	}
	return nil
}

func (x *Cluster) GetEncryptionConfig() *EncryptionConfig {
	if x != nil {
		return x.EncryptionConfig
	}
	return nil
}

func (x *Cluster) GetEncryptionInfo() *EncryptionInfo {
	if x != nil {
		return x.EncryptionInfo
	}
	return nil
}

func (x *Cluster) GetSecondaryConfig() *Cluster_SecondaryConfig {
	if x != nil {
		return x.SecondaryConfig
	}
	return nil
}

func (x *Cluster) GetPrimaryConfig() *Cluster_PrimaryConfig {
	if x != nil {
		return x.PrimaryConfig
	}
	return nil
}

type isCluster_Source interface {
	isCluster_Source()
}

type Cluster_BackupSource struct {
	// Output only. Cluster created from backup.
	BackupSource *BackupSource `protobuf:"bytes,15,opt,name=backup_source,json=backupSource,proto3,oneof"`
}

type Cluster_MigrationSource struct {
	// Output only. Cluster created via DMS migration.
	MigrationSource *MigrationSource `protobuf:"bytes,16,opt,name=migration_source,json=migrationSource,proto3,oneof"`
}

func (*Cluster_BackupSource) isCluster_Source() {}

func (*Cluster_MigrationSource) isCluster_Source() {}

// An Instance is a computing unit that an end customer can connect to.
// It's the main unit of computing resources in AlloyDB.
type Instance struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The name of the instance resource with the format:
	//   - projects/{project}/locations/{region}/clusters/{cluster_id}/instances/{instance_id}
	//
	// where the cluster and instance ID segments should satisfy the regex
	// expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
	// lowercase letters, numbers, and dashes, starting with a letter, and ending
	// with a letter or number. For more details see https://google.aip.dev/122.
	// The prefix of the instance resource name is the name of the parent
	// resource:
	//   - projects/{project}/locations/{region}/clusters/{cluster_id}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// User-settable and human-readable display name for the Instance.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Output only. The system-generated UID of the resource. The UID is assigned
	// when the resource is created, and it is retained until it is deleted.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// Output only. Create time stamp
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. Update time stamp
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Output only. Delete time stamp
	DeleteTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=delete_time,json=deleteTime,proto3" json:"delete_time,omitempty"`
	// Labels as key value pairs
	Labels map[string]string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. The current serving state of the instance.
	State Instance_State `protobuf:"varint,8,opt,name=state,proto3,enum=google.events.cloud.alloydb.v1.Instance_State" json:"state,omitempty"`
	// Required. The type of the instance. Specified at creation time.
	InstanceType Instance_InstanceType `protobuf:"varint,9,opt,name=instance_type,json=instanceType,proto3,enum=google.events.cloud.alloydb.v1.Instance_InstanceType" json:"instance_type,omitempty"`
	// Configurations for the machines that host the underlying
	// database engine.
	MachineConfig *Instance_MachineConfig `protobuf:"bytes,10,opt,name=machine_config,json=machineConfig,proto3" json:"machine_config,omitempty"`
	// Availability type of an Instance.
	// If empty, defaults to REGIONAL for primary instances.
	// For read pools, availability_type is always UNSPECIFIED. Instances in the
	// read pools are evenly distributed across available zones within the region
	// (i.e. read pools with more than one node will have a node in at
	// least two zones).
	AvailabilityType Instance_AvailabilityType `protobuf:"varint,11,opt,name=availability_type,json=availabilityType,proto3,enum=google.events.cloud.alloydb.v1.Instance_AvailabilityType" json:"availability_type,omitempty"`
	// The Compute Engine zone that the instance should serve from, per
	// https://cloud.google.com/compute/docs/regions-zones
	// This can ONLY be specified for ZONAL instances.
	// If present for a REGIONAL instance, an error will be thrown.
	// If this is absent for a ZONAL instance, instance is created in a random
	// zone with available capacity.
	GceZone string `protobuf:"bytes,12,opt,name=gce_zone,json=gceZone,proto3" json:"gce_zone,omitempty"`
	// Database flags. Set at instance level.
	//   - They are copied from primary instance on read instance creation.
	//   - Read instances can set new or override existing flags that are relevant
	//     for reads, e.g. for enabling columnar cache on a read instance. Flags
	//     set on read instance may or may not be present on primary.
	//
	// This is a list of "key": "value" pairs.
	// "key": The name of the flag. These flags are passed at instance setup time,
	// so include both server options and system variables for Postgres. Flags are
	// specified with underscores, not hyphens.
	// "value": The value of the flag. Booleans are set to **on** for true
	// and **off** for false. This field must be omitted if the flag
	// doesn't take a value.
	DatabaseFlags map[string]string `protobuf:"bytes,13,rep,name=database_flags,json=databaseFlags,proto3" json:"database_flags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. This is set for the read-write VM of the PRIMARY instance
	// only.
	WritableNode *Instance_Node `protobuf:"bytes,19,opt,name=writable_node,json=writableNode,proto3" json:"writable_node,omitempty"`
	// Output only. List of available read-only VMs in this instance, including
	// the standby for a PRIMARY instance.
	Nodes []*Instance_Node `protobuf:"bytes,20,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Configuration for query insights.
	QueryInsightsConfig *Instance_QueryInsightsInstanceConfig `protobuf:"bytes,21,opt,name=query_insights_config,json=queryInsightsConfig,proto3" json:"query_insights_config,omitempty"`
	// Read pool specific config.
	ReadPoolConfig *Instance_ReadPoolConfig `protobuf:"bytes,14,opt,name=read_pool_config,json=readPoolConfig,proto3" json:"read_pool_config,omitempty"`
	// Output only. The IP address for the Instance.
	// This is the connection endpoint for an end-user application.
	IpAddress string `protobuf:"bytes,15,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Instance does not match the user's
	// intended state, and the service is actively updating the resource to
	// reconcile them. This can happen due to user-triggered updates or
	// system actions like failover or maintenance.
	Reconciling bool `protobuf:"varint,16,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag string `protobuf:"bytes,17,opt,name=etag,proto3" json:"etag,omitempty"`
	// Annotations to allow client tools to store small amount of arbitrary data.
	// This is distinct from labels.
	// https://google.aip.dev/128
	Annotations   map[string]string `protobuf:"bytes,18,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instance) Reset() {
	*x = Instance{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance) ProtoMessage() {}

func (x *Instance) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance.ProtoReflect.Descriptor instead.
func (*Instance) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8}
}

func (x *Instance) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Instance) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *Instance) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *Instance) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Instance) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Instance) GetDeleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.DeleteTime
	}
	return nil
}

func (x *Instance) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Instance) GetState() Instance_State {
	if x != nil {
		return x.State
	}
	return Instance_STATE_UNSPECIFIED
}

func (x *Instance) GetInstanceType() Instance_InstanceType {
	if x != nil {
		return x.InstanceType
	}
	return Instance_INSTANCE_TYPE_UNSPECIFIED
}

func (x *Instance) GetMachineConfig() *Instance_MachineConfig {
	if x != nil {
		return x.MachineConfig
	}
	return nil
}

func (x *Instance) GetAvailabilityType() Instance_AvailabilityType {
	if x != nil {
		return x.AvailabilityType
	}
	return Instance_AVAILABILITY_TYPE_UNSPECIFIED
}

func (x *Instance) GetGceZone() string {
	if x != nil {
		return x.GceZone
	}
	return ""
}

func (x *Instance) GetDatabaseFlags() map[string]string {
	if x != nil {
		return x.DatabaseFlags
	}
	return nil
}

func (x *Instance) GetWritableNode() *Instance_Node {
	if x != nil {
		return x.WritableNode
	}
	return nil
}

func (x *Instance) GetNodes() []*Instance_Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *Instance) GetQueryInsightsConfig() *Instance_QueryInsightsInstanceConfig {
	if x != nil {
		return x.QueryInsightsConfig
	}
	return nil
}

func (x *Instance) GetReadPoolConfig() *Instance_ReadPoolConfig {
	if x != nil {
		return x.ReadPoolConfig
	}
	return nil
}

func (x *Instance) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *Instance) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

func (x *Instance) GetEtag() string {
	if x != nil {
		return x.Etag
	}
	return ""
}

func (x *Instance) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

// Message describing Backup object
type Backup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The name of the backup resource with the format:
	//   - projects/{project}/locations/{region}/backups/{backup_id}
	//
	// where the cluster and backup ID segments should satisfy the regex
	// expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
	// lowercase letters, numbers, and dashes, starting with a letter, and ending
	// with a letter or number. For more details see https://google.aip.dev/122.
	// The prefix of the backup resource name is the name of the parent
	// resource:
	//   - projects/{project}/locations/{region}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// User-settable and human-readable display name for the Backup.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Output only. The system-generated UID of the resource. The UID is assigned
	// when the resource is created, and it is retained until it is deleted.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// Output only. Create time stamp
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. Update time stamp
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Output only. Delete time stamp
	DeleteTime *timestamppb.Timestamp `protobuf:"bytes,15,opt,name=delete_time,json=deleteTime,proto3" json:"delete_time,omitempty"`
	// Labels as key value pairs
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. The current state of the backup.
	State Backup_State `protobuf:"varint,7,opt,name=state,proto3,enum=google.events.cloud.alloydb.v1.Backup_State" json:"state,omitempty"`
	// The backup type, which suggests the trigger for the backup.
	Type Backup_Type `protobuf:"varint,8,opt,name=type,proto3,enum=google.events.cloud.alloydb.v1.Backup_Type" json:"type,omitempty"`
	// User-provided description of the backup.
	Description string `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	// Output only. The system-generated UID of the cluster which was used to
	// create this resource.
	ClusterUid string `protobuf:"bytes,18,opt,name=cluster_uid,json=clusterUid,proto3" json:"cluster_uid,omitempty"`
	// Required. The full resource name of the backup source cluster
	// (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
	ClusterName string `protobuf:"bytes,10,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation), if
	// true, indicates that the service is actively updating the resource. This
	// can happen due to user-triggered updates or system actions like failover or
	// maintenance.
	Reconciling bool `protobuf:"varint,11,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	// Optional. The encryption config can be specified to encrypt the
	// backup with a customer-managed encryption key (CMEK). When this field is
	// not specified, the backup will then use default encryption scheme to
	// protect the user data.
	EncryptionConfig *EncryptionConfig `protobuf:"bytes,12,opt,name=encryption_config,json=encryptionConfig,proto3" json:"encryption_config,omitempty"`
	// Output only. The encryption information for the backup.
	EncryptionInfo *EncryptionInfo `protobuf:"bytes,13,opt,name=encryption_info,json=encryptionInfo,proto3" json:"encryption_info,omitempty"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag string `protobuf:"bytes,14,opt,name=etag,proto3" json:"etag,omitempty"`
	// Annotations to allow client tools to store small amount of arbitrary data.
	// This is distinct from labels.
	// https://google.aip.dev/128
	Annotations map[string]string `protobuf:"bytes,16,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Output only. The size of the backup in bytes.
	SizeBytes int64 `protobuf:"varint,17,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Output only. The time at which after the backup is eligible to be garbage
	// collected. It is the duration specified by the backup's retention policy,
	// added to the backup's create_time.
	ExpiryTime    *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backup) Reset() {
	*x = Backup{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup) ProtoMessage() {}

func (x *Backup) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup.ProtoReflect.Descriptor instead.
func (*Backup) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{9}
}

func (x *Backup) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Backup) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *Backup) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *Backup) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Backup) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Backup) GetDeleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.DeleteTime
	}
	return nil
}

func (x *Backup) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Backup) GetState() Backup_State {
	if x != nil {
		return x.State
	}
	return Backup_STATE_UNSPECIFIED
}

func (x *Backup) GetType() Backup_Type {
	if x != nil {
		return x.Type
	}
	return Backup_TYPE_UNSPECIFIED
}

func (x *Backup) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Backup) GetClusterUid() string {
	if x != nil {
		return x.ClusterUid
	}
	return ""
}

func (x *Backup) GetClusterName() string {
	if x != nil {
		return x.ClusterName
	}
	return ""
}

func (x *Backup) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

func (x *Backup) GetEncryptionConfig() *EncryptionConfig {
	if x != nil {
		return x.EncryptionConfig
	}
	return nil
}

func (x *Backup) GetEncryptionInfo() *EncryptionInfo {
	if x != nil {
		return x.EncryptionInfo
	}
	return nil
}

func (x *Backup) GetEtag() string {
	if x != nil {
		return x.Etag
	}
	return ""
}

func (x *Backup) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *Backup) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *Backup) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

// The data within all Instance events.
type InstanceEventData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. The Instance event payload. Unset for deletion events.
	Payload       *Instance `protobuf:"bytes,1,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstanceEventData) Reset() {
	*x = InstanceEventData{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceEventData) ProtoMessage() {}

func (x *InstanceEventData) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceEventData.ProtoReflect.Descriptor instead.
func (*InstanceEventData) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{10}
}

func (x *InstanceEventData) GetPayload() *Instance {
	if x != nil {
		return x.Payload
	}
	return nil
}

// The data within all Backup events.
type BackupEventData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. The Backup event payload. Unset for deletion events.
	Payload       *Backup `protobuf:"bytes,1,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupEventData) Reset() {
	*x = BackupEventData{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupEventData) ProtoMessage() {}

func (x *BackupEventData) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupEventData.ProtoReflect.Descriptor instead.
func (*BackupEventData) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{11}
}

func (x *BackupEventData) GetPayload() *Backup {
	if x != nil {
		return x.Payload
	}
	return nil
}

// The data within all Cluster events.
type ClusterEventData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. The Cluster event payload. Unset for deletion events.
	Payload       *Cluster `protobuf:"bytes,1,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterEventData) Reset() {
	*x = ClusterEventData{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterEventData) ProtoMessage() {}

func (x *ClusterEventData) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterEventData.ProtoReflect.Descriptor instead.
func (*ClusterEventData) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{12}
}

func (x *ClusterEventData) GetPayload() *Cluster {
	if x != nil {
		return x.Payload
	}
	return nil
}

// A weekly schedule starts a backup at prescribed start times within a
// day, for the specified days of the week.
//
// The weekly schedule message is flexible and can be used to create many
// types of schedules. For example, to have a daily backup that starts at
// 22:00, configure the `start_times` field to have one element "22:00" and
// the `days_of_week` field to have all seven days of the week.
type AutomatedBackupPolicy_WeeklySchedule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The times during the day to start a backup. The start times are assumed
	// to be in UTC and to be an exact hour (e.g., 04:00:00).
	//
	// If no start times are provided, a single fixed start time is chosen
	// arbitrarily.
	StartTimes []*timeofday.TimeOfDay `protobuf:"bytes,1,rep,name=start_times,json=startTimes,proto3" json:"start_times,omitempty"`
	// The days of the week to perform a backup.
	//
	// If this field is left empty, the default of every day of the week is
	// used.
	DaysOfWeek    []dayofweek.DayOfWeek `protobuf:"varint,2,rep,packed,name=days_of_week,json=daysOfWeek,proto3,enum=google.type.DayOfWeek" json:"days_of_week,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomatedBackupPolicy_WeeklySchedule) Reset() {
	*x = AutomatedBackupPolicy_WeeklySchedule{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomatedBackupPolicy_WeeklySchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatedBackupPolicy_WeeklySchedule) ProtoMessage() {}

func (x *AutomatedBackupPolicy_WeeklySchedule) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatedBackupPolicy_WeeklySchedule.ProtoReflect.Descriptor instead.
func (*AutomatedBackupPolicy_WeeklySchedule) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{5, 0}
}

func (x *AutomatedBackupPolicy_WeeklySchedule) GetStartTimes() []*timeofday.TimeOfDay {
	if x != nil {
		return x.StartTimes
	}
	return nil
}

func (x *AutomatedBackupPolicy_WeeklySchedule) GetDaysOfWeek() []dayofweek.DayOfWeek {
	if x != nil {
		return x.DaysOfWeek
	}
	return nil
}

// A time based retention policy specifies that all backups within a certain
// time period should be retained.
type AutomatedBackupPolicy_TimeBasedRetention struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The retention period.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,1,opt,name=retention_period,json=retentionPeriod,proto3" json:"retention_period,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AutomatedBackupPolicy_TimeBasedRetention) Reset() {
	*x = AutomatedBackupPolicy_TimeBasedRetention{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomatedBackupPolicy_TimeBasedRetention) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatedBackupPolicy_TimeBasedRetention) ProtoMessage() {}

func (x *AutomatedBackupPolicy_TimeBasedRetention) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatedBackupPolicy_TimeBasedRetention.ProtoReflect.Descriptor instead.
func (*AutomatedBackupPolicy_TimeBasedRetention) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{5, 1}
}

func (x *AutomatedBackupPolicy_TimeBasedRetention) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

// A quantity based policy specifies that a certain number of the most recent
// successful backups should be retained.
type AutomatedBackupPolicy_QuantityBasedRetention struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of backups to retain.
	Count         int32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomatedBackupPolicy_QuantityBasedRetention) Reset() {
	*x = AutomatedBackupPolicy_QuantityBasedRetention{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomatedBackupPolicy_QuantityBasedRetention) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatedBackupPolicy_QuantityBasedRetention) ProtoMessage() {}

func (x *AutomatedBackupPolicy_QuantityBasedRetention) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatedBackupPolicy_QuantityBasedRetention.ProtoReflect.Descriptor instead.
func (*AutomatedBackupPolicy_QuantityBasedRetention) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{5, 2}
}

func (x *AutomatedBackupPolicy_QuantityBasedRetention) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// Configuration information for the secondary cluster. This should be set
// if and only if the cluster is of type SECONDARY.
type Cluster_SecondaryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the primary cluster name with the format:
	// * projects/{project}/locations/{region}/clusters/{cluster_id}
	PrimaryClusterName string `protobuf:"bytes,1,opt,name=primary_cluster_name,json=primaryClusterName,proto3" json:"primary_cluster_name,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Cluster_SecondaryConfig) Reset() {
	*x = Cluster_SecondaryConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_SecondaryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_SecondaryConfig) ProtoMessage() {}

func (x *Cluster_SecondaryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_SecondaryConfig.ProtoReflect.Descriptor instead.
func (*Cluster_SecondaryConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{7, 0}
}

func (x *Cluster_SecondaryConfig) GetPrimaryClusterName() string {
	if x != nil {
		return x.PrimaryClusterName
	}
	return ""
}

// Configuration for the primary cluster. It has the list of clusters that are
// replicating from this cluster. This should be set if and only if the
// cluster is of type PRIMARY.
type Cluster_PrimaryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. Names of the clusters that are replicating from this
	// cluster.
	SecondaryClusterNames []string `protobuf:"bytes,1,rep,name=secondary_cluster_names,json=secondaryClusterNames,proto3" json:"secondary_cluster_names,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Cluster_PrimaryConfig) Reset() {
	*x = Cluster_PrimaryConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_PrimaryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_PrimaryConfig) ProtoMessage() {}

func (x *Cluster_PrimaryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_PrimaryConfig.ProtoReflect.Descriptor instead.
func (*Cluster_PrimaryConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{7, 1}
}

func (x *Cluster_PrimaryConfig) GetSecondaryClusterNames() []string {
	if x != nil {
		return x.SecondaryClusterNames
	}
	return nil
}

// MachineConfig describes the configuration of a machine.
type Instance_MachineConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of CPU's in the VM instance.
	CpuCount      int32 `protobuf:"varint,1,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instance_MachineConfig) Reset() {
	*x = Instance_MachineConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance_MachineConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance_MachineConfig) ProtoMessage() {}

func (x *Instance_MachineConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance_MachineConfig.ProtoReflect.Descriptor instead.
func (*Instance_MachineConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 0}
}

func (x *Instance_MachineConfig) GetCpuCount() int32 {
	if x != nil {
		return x.CpuCount
	}
	return 0
}

// Details of a single node in the instance.
// Nodes in an AlloyDB instance are ephemereal, they can change during
// update, failover, autohealing and resize operations.
type Instance_Node struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Compute Engine zone of the VM e.g. "us-central1-b".
	ZoneId string `protobuf:"bytes,1,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	// The identifier of the VM e.g. "test-read-0601-407e52be-ms3l".
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The private IP address of the VM e.g. "10.57.0.34".
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	// Determined by state of the compute VM and postgres-service health.
	// Compute VM state can have values listed in
	// https://cloud.google.com/compute/docs/instances/instance-life-cycle and
	// postgres-service health can have values: HEALTHY and UNHEALTHY.
	State         string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instance_Node) Reset() {
	*x = Instance_Node{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance_Node) ProtoMessage() {}

func (x *Instance_Node) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance_Node.ProtoReflect.Descriptor instead.
func (*Instance_Node) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 1}
}

func (x *Instance_Node) GetZoneId() string {
	if x != nil {
		return x.ZoneId
	}
	return ""
}

func (x *Instance_Node) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Instance_Node) GetIp() string {
	if x != nil {
		return x.Ip
	}
	return ""
}

func (x *Instance_Node) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

// QueryInsights Instance specific configuration.
type Instance_QueryInsightsInstanceConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Record application tags for an instance.
	// This flag is turned "on" by default.
	RecordApplicationTags *bool `protobuf:"varint,2,opt,name=record_application_tags,json=recordApplicationTags,proto3,oneof" json:"record_application_tags,omitempty"`
	// Record client address for an instance. Client address is PII information.
	// This flag is turned "on" by default.
	RecordClientAddress *bool `protobuf:"varint,3,opt,name=record_client_address,json=recordClientAddress,proto3,oneof" json:"record_client_address,omitempty"`
	// Query string length. The default value is 1024.
	// Any integer between 256 and 4500 is considered valid.
	QueryStringLength uint32 `protobuf:"varint,4,opt,name=query_string_length,json=queryStringLength,proto3" json:"query_string_length,omitempty"`
	// Number of query execution plans captured by Insights per minute
	// for all queries combined. The default value is 5.
	// Any integer between 0 and 20 is considered valid.
	QueryPlansPerMinute *uint32 `protobuf:"varint,5,opt,name=query_plans_per_minute,json=queryPlansPerMinute,proto3,oneof" json:"query_plans_per_minute,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Instance_QueryInsightsInstanceConfig) Reset() {
	*x = Instance_QueryInsightsInstanceConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance_QueryInsightsInstanceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance_QueryInsightsInstanceConfig) ProtoMessage() {}

func (x *Instance_QueryInsightsInstanceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance_QueryInsightsInstanceConfig.ProtoReflect.Descriptor instead.
func (*Instance_QueryInsightsInstanceConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 2}
}

func (x *Instance_QueryInsightsInstanceConfig) GetRecordApplicationTags() bool {
	if x != nil && x.RecordApplicationTags != nil {
		return *x.RecordApplicationTags
	}
	return false
}

func (x *Instance_QueryInsightsInstanceConfig) GetRecordClientAddress() bool {
	if x != nil && x.RecordClientAddress != nil {
		return *x.RecordClientAddress
	}
	return false
}

func (x *Instance_QueryInsightsInstanceConfig) GetQueryStringLength() uint32 {
	if x != nil {
		return x.QueryStringLength
	}
	return 0
}

func (x *Instance_QueryInsightsInstanceConfig) GetQueryPlansPerMinute() uint32 {
	if x != nil && x.QueryPlansPerMinute != nil {
		return *x.QueryPlansPerMinute
	}
	return 0
}

// Configuration for a read pool instance.
type Instance_ReadPoolConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Read capacity, i.e. number of nodes in a read pool instance.
	NodeCount     int32 `protobuf:"varint,1,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instance_ReadPoolConfig) Reset() {
	*x = Instance_ReadPoolConfig{}
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance_ReadPoolConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance_ReadPoolConfig) ProtoMessage() {}

func (x *Instance_ReadPoolConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_alloydb_v1_data_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance_ReadPoolConfig.ProtoReflect.Descriptor instead.
func (*Instance_ReadPoolConfig) Descriptor() ([]byte, []int) {
	return file_cloud_alloydb_v1_data_proto_rawDescGZIP(), []int{8, 3}
}

func (x *Instance_ReadPoolConfig) GetNodeCount() int32 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

var File_cloud_alloydb_v1_data_proto protoreflect.FileDescriptor

const file_cloud_alloydb_v1_data_proto_rawDesc = "" +
	"\n" +
	"\x1bcloud/alloydb/v1/data.proto\x12\x1egoogle.events.cloud.alloydb.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/type/dayofweek.proto\x1a\x1bgoogle/type/timeofday.proto\">\n" +
	"\fUserPassword\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\"\xfe\x01\n" +
	"\x0fMigrationSource\x12\x1b\n" +
	"\thost_port\x18\x01 \x01(\tR\bhostPort\x12!\n" +
	"\freference_id\x18\x02 \x01(\tR\vreferenceId\x12d\n" +
	"\vsource_type\x18\x03 \x01(\x0e2C.google.events.cloud.alloydb.v1.MigrationSource.MigrationSourceTypeR\n" +
	"sourceType\"E\n" +
	"\x13MigrationSourceType\x12%\n" +
	"!MIGRATION_SOURCE_TYPE_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03DMS\x10\x01\"4\n" +
	"\x10EncryptionConfig\x12 \n" +
	"\fkms_key_name\x18\x01 \x01(\tR\n" +
	"kmsKeyName\"\xf6\x01\n" +
	"\x0eEncryptionInfo\x12\\\n" +
	"\x0fencryption_type\x18\x01 \x01(\x0e23.google.events.cloud.alloydb.v1.EncryptionInfo.TypeR\x0eencryptionType\x12(\n" +
	"\x10kms_key_versions\x18\x02 \x03(\tR\x0ekmsKeyVersions\"\\\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19GOOGLE_DEFAULT_ENCRYPTION\x10\x01\x12\x1f\n" +
	"\x1bCUSTOMER_MANAGED_ENCRYPTION\x10\x02\"\xcf\x02\n" +
	"\tSslConfig\x12L\n" +
	"\bssl_mode\x18\x01 \x01(\x0e21.google.events.cloud.alloydb.v1.SslConfig.SslModeR\asslMode\x12O\n" +
	"\tca_source\x18\x02 \x01(\x0e22.google.events.cloud.alloydb.v1.SslConfig.CaSourceR\bcaSource\"e\n" +
	"\aSslMode\x12\x18\n" +
	"\x14SSL_MODE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSSL_MODE_ALLOW\x10\x01\x12\x14\n" +
	"\x10SSL_MODE_REQUIRE\x10\x02\x12\x16\n" +
	"\x12SSL_MODE_VERIFY_CA\x10\x03\"<\n" +
	"\bCaSource\x12\x19\n" +
	"\x15CA_SOURCE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11CA_SOURCE_MANAGED\x10\x01\"\xb8\b\n" +
	"\x15AutomatedBackupPolicy\x12o\n" +
	"\x0fweekly_schedule\x18\x02 \x01(\v2D.google.events.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklyScheduleH\x00R\x0eweeklySchedule\x12|\n" +
	"\x14time_based_retention\x18\x04 \x01(\v2H.google.events.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetentionH\x01R\x12timeBasedRetention\x12\x88\x01\n" +
	"\x18quantity_based_retention\x18\x05 \x01(\v2L.google.events.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetentionH\x01R\x16quantityBasedRetention\x12\x1d\n" +
	"\aenabled\x18\x01 \x01(\bH\x02R\aenabled\x88\x01\x01\x12>\n" +
	"\rbackup_window\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\fbackupWindow\x12]\n" +
	"\x11encryption_config\x18\b \x01(\v20.google.events.cloud.alloydb.v1.EncryptionConfigR\x10encryptionConfig\x12\x1a\n" +
	"\blocation\x18\x06 \x01(\tR\blocation\x12Y\n" +
	"\x06labels\x18\a \x03(\v2A.google.events.cloud.alloydb.v1.AutomatedBackupPolicy.LabelsEntryR\x06labels\x1a\x83\x01\n" +
	"\x0eWeeklySchedule\x127\n" +
	"\vstart_times\x18\x01 \x03(\v2\x16.google.type.TimeOfDayR\n" +
	"startTimes\x128\n" +
	"\fdays_of_week\x18\x02 \x03(\x0e2\x16.google.type.DayOfWeekR\n" +
	"daysOfWeek\x1aZ\n" +
	"\x12TimeBasedRetention\x12D\n" +
	"\x10retention_period\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x0fretentionPeriod\x1a.\n" +
	"\x16QuantityBasedRetention\x12\x14\n" +
	"\x05count\x18\x01 \x01(\x05R\x05count\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\n" +
	"\n" +
	"\bscheduleB\v\n" +
	"\tretentionB\n" +
	"\n" +
	"\b_enabled\"N\n" +
	"\fBackupSource\x12\x1d\n" +
	"\n" +
	"backup_uid\x18\x02 \x01(\tR\tbackupUid\x12\x1f\n" +
	"\vbackup_name\x18\x01 \x01(\tR\n" +
	"backupName\"\xdc\x0f\n" +
	"\aCluster\x12S\n" +
	"\rbackup_source\x18\x0f \x01(\v2,.google.events.cloud.alloydb.v1.BackupSourceH\x00R\fbackupSource\x12\\\n" +
	"\x10migration_source\x18\x10 \x01(\v2/.google.events.cloud.alloydb.v1.MigrationSourceH\x00R\x0fmigrationSource\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x02 \x01(\tR\vdisplayName\x12\x10\n" +
	"\x03uid\x18\x03 \x01(\tR\x03uid\x12;\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12;\n" +
	"\vdelete_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"deleteTime\x12K\n" +
	"\x06labels\x18\a \x03(\v23.google.events.cloud.alloydb.v1.Cluster.LabelsEntryR\x06labels\x12C\n" +
	"\x05state\x18\b \x01(\x0e2-.google.events.cloud.alloydb.v1.Cluster.StateR\x05state\x12V\n" +
	"\fcluster_type\x18\x18 \x01(\x0e23.google.events.cloud.alloydb.v1.Cluster.ClusterTypeR\vclusterType\x12Z\n" +
	"\x10database_version\x18\t \x01(\x0e2/.google.events.cloud.alloydb.v1.DatabaseVersionR\x0fdatabaseVersion\x12\x18\n" +
	"\anetwork\x18\n" +
	" \x01(\tR\anetwork\x12\x12\n" +
	"\x04etag\x18\v \x01(\tR\x04etag\x12Z\n" +
	"\vannotations\x18\f \x03(\v28.google.events.cloud.alloydb.v1.Cluster.AnnotationsEntryR\vannotations\x12 \n" +
	"\vreconciling\x18\r \x01(\bR\vreconciling\x12m\n" +
	"\x17automated_backup_policy\x18\x11 \x01(\v25.google.events.cloud.alloydb.v1.AutomatedBackupPolicyR\x15automatedBackupPolicy\x12H\n" +
	"\n" +
	"ssl_config\x18\x12 \x01(\v2).google.events.cloud.alloydb.v1.SslConfigR\tsslConfig\x12]\n" +
	"\x11encryption_config\x18\x13 \x01(\v20.google.events.cloud.alloydb.v1.EncryptionConfigR\x10encryptionConfig\x12W\n" +
	"\x0fencryption_info\x18\x14 \x01(\v2..google.events.cloud.alloydb.v1.EncryptionInfoR\x0eencryptionInfo\x12b\n" +
	"\x10secondary_config\x18\x16 \x01(\v27.google.events.cloud.alloydb.v1.Cluster.SecondaryConfigR\x0fsecondaryConfig\x12\\\n" +
	"\x0eprimary_config\x18\x17 \x01(\v25.google.events.cloud.alloydb.v1.Cluster.PrimaryConfigR\rprimaryConfig\x1aC\n" +
	"\x0fSecondaryConfig\x120\n" +
	"\x14primary_cluster_name\x18\x01 \x01(\tR\x12primaryClusterName\x1aG\n" +
	"\rPrimaryConfig\x126\n" +
	"\x17secondary_cluster_names\x18\x01 \x03(\tR\x15secondaryClusterNames\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10AnnotationsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9c\x01\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05READY\x10\x01\x12\v\n" +
	"\aSTOPPED\x10\x02\x12\t\n" +
	"\x05EMPTY\x10\x03\x12\f\n" +
	"\bCREATING\x10\x04\x12\f\n" +
	"\bDELETING\x10\x05\x12\n" +
	"\n" +
	"\x06FAILED\x10\x06\x12\x11\n" +
	"\rBOOTSTRAPPING\x10\a\x12\x0f\n" +
	"\vMAINTENANCE\x10\b\x12\r\n" +
	"\tPROMOTING\x10\t\"G\n" +
	"\vClusterType\x12\x1c\n" +
	"\x18CLUSTER_TYPE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\r\n" +
	"\tSECONDARY\x10\x02B\b\n" +
	"\x06source\"\xea\x12\n" +
	"\bInstance\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x02 \x01(\tR\vdisplayName\x12\x10\n" +
	"\x03uid\x18\x03 \x01(\tR\x03uid\x12;\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12;\n" +
	"\vdelete_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"deleteTime\x12L\n" +
	"\x06labels\x18\a \x03(\v24.google.events.cloud.alloydb.v1.Instance.LabelsEntryR\x06labels\x12D\n" +
	"\x05state\x18\b \x01(\x0e2..google.events.cloud.alloydb.v1.Instance.StateR\x05state\x12Z\n" +
	"\rinstance_type\x18\t \x01(\x0e25.google.events.cloud.alloydb.v1.Instance.InstanceTypeR\finstanceType\x12]\n" +
	"\x0emachine_config\x18\n" +
	" \x01(\v26.google.events.cloud.alloydb.v1.Instance.MachineConfigR\rmachineConfig\x12f\n" +
	"\x11availability_type\x18\v \x01(\x0e29.google.events.cloud.alloydb.v1.Instance.AvailabilityTypeR\x10availabilityType\x12\x19\n" +
	"\bgce_zone\x18\f \x01(\tR\agceZone\x12b\n" +
	"\x0edatabase_flags\x18\r \x03(\v2;.google.events.cloud.alloydb.v1.Instance.DatabaseFlagsEntryR\rdatabaseFlags\x12R\n" +
	"\rwritable_node\x18\x13 \x01(\v2-.google.events.cloud.alloydb.v1.Instance.NodeR\fwritableNode\x12C\n" +
	"\x05nodes\x18\x14 \x03(\v2-.google.events.cloud.alloydb.v1.Instance.NodeR\x05nodes\x12x\n" +
	"\x15query_insights_config\x18\x15 \x01(\v2D.google.events.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfigR\x13queryInsightsConfig\x12a\n" +
	"\x10read_pool_config\x18\x0e \x01(\v27.google.events.cloud.alloydb.v1.Instance.ReadPoolConfigR\x0ereadPoolConfig\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x0f \x01(\tR\tipAddress\x12 \n" +
	"\vreconciling\x18\x10 \x01(\bR\vreconciling\x12\x12\n" +
	"\x04etag\x18\x11 \x01(\tR\x04etag\x12[\n" +
	"\vannotations\x18\x12 \x03(\v29.google.events.cloud.alloydb.v1.Instance.AnnotationsEntryR\vannotations\x1a,\n" +
	"\rMachineConfig\x12\x1b\n" +
	"\tcpu_count\x18\x01 \x01(\x05R\bcpuCount\x1aU\n" +
	"\x04Node\x12\x17\n" +
	"\azone_id\x18\x01 \x01(\tR\x06zoneId\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\x12\x0e\n" +
	"\x02ip\x18\x03 \x01(\tR\x02ip\x12\x14\n" +
	"\x05state\x18\x04 \x01(\tR\x05state\x1a\xce\x02\n" +
	"\x1bQueryInsightsInstanceConfig\x12;\n" +
	"\x17record_application_tags\x18\x02 \x01(\bH\x00R\x15recordApplicationTags\x88\x01\x01\x127\n" +
	"\x15record_client_address\x18\x03 \x01(\bH\x01R\x13recordClientAddress\x88\x01\x01\x12.\n" +
	"\x13query_string_length\x18\x04 \x01(\rR\x11queryStringLength\x128\n" +
	"\x16query_plans_per_minute\x18\x05 \x01(\rH\x02R\x13queryPlansPerMinute\x88\x01\x01B\x1a\n" +
	"\x18_record_application_tagsB\x18\n" +
	"\x16_record_client_addressB\x19\n" +
	"\x17_query_plans_per_minute\x1a/\n" +
	"\x0eReadPoolConfig\x12\x1d\n" +
	"\n" +
	"node_count\x18\x01 \x01(\x05R\tnodeCount\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a@\n" +
	"\x12DatabaseFlagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10AnnotationsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x91\x01\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05READY\x10\x01\x12\v\n" +
	"\aSTOPPED\x10\x02\x12\f\n" +
	"\bCREATING\x10\x03\x12\f\n" +
	"\bDELETING\x10\x04\x12\x0f\n" +
	"\vMAINTENANCE\x10\x05\x12\n" +
	"\n" +
	"\x06FAILED\x10\x06\x12\x11\n" +
	"\rBOOTSTRAPPING\x10\b\x12\r\n" +
	"\tPROMOTING\x10\t\"X\n" +
	"\fInstanceType\x12\x1d\n" +
	"\x19INSTANCE_TYPE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\r\n" +
	"\tREAD_POOL\x10\x02\x12\r\n" +
	"\tSECONDARY\x10\x03\"N\n" +
	"\x10AvailabilityType\x12!\n" +
	"\x1dAVAILABILITY_TYPE_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05ZONAL\x10\x01\x12\f\n" +
	"\bREGIONAL\x10\x02\"\xfe\t\n" +
	"\x06Backup\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x02 \x01(\tR\vdisplayName\x12\x10\n" +
	"\x03uid\x18\x03 \x01(\tR\x03uid\x12;\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12;\n" +
	"\vdelete_time\x18\x0f \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"deleteTime\x12J\n" +
	"\x06labels\x18\x06 \x03(\v22.google.events.cloud.alloydb.v1.Backup.LabelsEntryR\x06labels\x12B\n" +
	"\x05state\x18\a \x01(\x0e2,.google.events.cloud.alloydb.v1.Backup.StateR\x05state\x12?\n" +
	"\x04type\x18\b \x01(\x0e2+.google.events.cloud.alloydb.v1.Backup.TypeR\x04type\x12 \n" +
	"\vdescription\x18\t \x01(\tR\vdescription\x12\x1f\n" +
	"\vcluster_uid\x18\x12 \x01(\tR\n" +
	"clusterUid\x12!\n" +
	"\fcluster_name\x18\n" +
	" \x01(\tR\vclusterName\x12 \n" +
	"\vreconciling\x18\v \x01(\bR\vreconciling\x12]\n" +
	"\x11encryption_config\x18\f \x01(\v20.google.events.cloud.alloydb.v1.EncryptionConfigR\x10encryptionConfig\x12W\n" +
	"\x0fencryption_info\x18\r \x01(\v2..google.events.cloud.alloydb.v1.EncryptionInfoR\x0eencryptionInfo\x12\x12\n" +
	"\x04etag\x18\x0e \x01(\tR\x04etag\x12Y\n" +
	"\vannotations\x18\x10 \x03(\v27.google.events.cloud.alloydb.v1.Backup.AnnotationsEntryR\vannotations\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x11 \x01(\x03R\tsizeBytes\x12;\n" +
	"\vexpiry_time\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10AnnotationsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"Q\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05READY\x10\x01\x12\f\n" +
	"\bCREATING\x10\x02\x12\n" +
	"\n" +
	"\x06FAILED\x10\x03\x12\f\n" +
	"\bDELETING\x10\x04\"J\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tON_DEMAND\x10\x01\x12\r\n" +
	"\tAUTOMATED\x10\x02\x12\x0e\n" +
	"\n" +
	"CONTINUOUS\x10\x03\"h\n" +
	"\x11InstanceEventData\x12G\n" +
	"\apayload\x18\x01 \x01(\v2(.google.events.cloud.alloydb.v1.InstanceH\x00R\apayload\x88\x01\x01B\n" +
	"\n" +
	"\b_payload\"d\n" +
	"\x0fBackupEventData\x12E\n" +
	"\apayload\x18\x01 \x01(\v2&.google.events.cloud.alloydb.v1.BackupH\x00R\apayload\x88\x01\x01B\n" +
	"\n" +
	"\b_payload\"f\n" +
	"\x10ClusterEventData\x12F\n" +
	"\apayload\x18\x01 \x01(\v2'.google.events.cloud.alloydb.v1.ClusterH\x00R\apayload\x88\x01\x01B\n" +
	"\n" +
	"\b_payload*U\n" +
	"\x0fDatabaseVersion\x12 \n" +
	"\x1cDATABASE_VERSION_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vPOSTGRES_13\x10\x01\x12\x0f\n" +
	"\vPOSTGRES_14\x10\x02Bp\xaa\x02'Google.Events.Protobuf.Cloud.AlloyDb.V1\xca\x02\x1eGoogle\\Events\\Cloud\\AlloyDb\\V1\xea\x02\"Google::Events::Cloud::AlloyDB::V1b\x06proto3"

var (
	file_cloud_alloydb_v1_data_proto_rawDescOnce sync.Once
	file_cloud_alloydb_v1_data_proto_rawDescData []byte
)

func file_cloud_alloydb_v1_data_proto_rawDescGZIP() []byte {
	file_cloud_alloydb_v1_data_proto_rawDescOnce.Do(func() {
		file_cloud_alloydb_v1_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cloud_alloydb_v1_data_proto_rawDesc), len(file_cloud_alloydb_v1_data_proto_rawDesc)))
	})
	return file_cloud_alloydb_v1_data_proto_rawDescData
}

var file_cloud_alloydb_v1_data_proto_enumTypes = make([]protoimpl.EnumInfo, 12)
var file_cloud_alloydb_v1_data_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_cloud_alloydb_v1_data_proto_goTypes = []any{
	(DatabaseVersion)(0),                                 // 0: google.events.cloud.alloydb.v1.DatabaseVersion
	(MigrationSource_MigrationSourceType)(0),             // 1: google.events.cloud.alloydb.v1.MigrationSource.MigrationSourceType
	(EncryptionInfo_Type)(0),                             // 2: google.events.cloud.alloydb.v1.EncryptionInfo.Type
	(SslConfig_SslMode)(0),                               // 3: google.events.cloud.alloydb.v1.SslConfig.SslMode
	(SslConfig_CaSource)(0),                              // 4: google.events.cloud.alloydb.v1.SslConfig.CaSource
	(Cluster_State)(0),                                   // 5: google.events.cloud.alloydb.v1.Cluster.State
	(Cluster_ClusterType)(0),                             // 6: google.events.cloud.alloydb.v1.Cluster.ClusterType
	(Instance_State)(0),                                  // 7: google.events.cloud.alloydb.v1.Instance.State
	(Instance_InstanceType)(0),                           // 8: google.events.cloud.alloydb.v1.Instance.InstanceType
	(Instance_AvailabilityType)(0),                       // 9: google.events.cloud.alloydb.v1.Instance.AvailabilityType
	(Backup_State)(0),                                    // 10: google.events.cloud.alloydb.v1.Backup.State
	(Backup_Type)(0),                                     // 11: google.events.cloud.alloydb.v1.Backup.Type
	(*UserPassword)(nil),                                 // 12: google.events.cloud.alloydb.v1.UserPassword
	(*MigrationSource)(nil),                              // 13: google.events.cloud.alloydb.v1.MigrationSource
	(*EncryptionConfig)(nil),                             // 14: google.events.cloud.alloydb.v1.EncryptionConfig
	(*EncryptionInfo)(nil),                               // 15: google.events.cloud.alloydb.v1.EncryptionInfo
	(*SslConfig)(nil),                                    // 16: google.events.cloud.alloydb.v1.SslConfig
	(*AutomatedBackupPolicy)(nil),                        // 17: google.events.cloud.alloydb.v1.AutomatedBackupPolicy
	(*BackupSource)(nil),                                 // 18: google.events.cloud.alloydb.v1.BackupSource
	(*Cluster)(nil),                                      // 19: google.events.cloud.alloydb.v1.Cluster
	(*Instance)(nil),                                     // 20: google.events.cloud.alloydb.v1.Instance
	(*Backup)(nil),                                       // 21: google.events.cloud.alloydb.v1.Backup
	(*InstanceEventData)(nil),                            // 22: google.events.cloud.alloydb.v1.InstanceEventData
	(*BackupEventData)(nil),                              // 23: google.events.cloud.alloydb.v1.BackupEventData
	(*ClusterEventData)(nil),                             // 24: google.events.cloud.alloydb.v1.ClusterEventData
	(*AutomatedBackupPolicy_WeeklySchedule)(nil),         // 25: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule
	(*AutomatedBackupPolicy_TimeBasedRetention)(nil),     // 26: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention
	(*AutomatedBackupPolicy_QuantityBasedRetention)(nil), // 27: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetention
	nil,                             // 28: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.LabelsEntry
	(*Cluster_SecondaryConfig)(nil), // 29: google.events.cloud.alloydb.v1.Cluster.SecondaryConfig
	(*Cluster_PrimaryConfig)(nil),   // 30: google.events.cloud.alloydb.v1.Cluster.PrimaryConfig
	nil,                             // 31: google.events.cloud.alloydb.v1.Cluster.LabelsEntry
	nil,                             // 32: google.events.cloud.alloydb.v1.Cluster.AnnotationsEntry
	(*Instance_MachineConfig)(nil),  // 33: google.events.cloud.alloydb.v1.Instance.MachineConfig
	(*Instance_Node)(nil),           // 34: google.events.cloud.alloydb.v1.Instance.Node
	(*Instance_QueryInsightsInstanceConfig)(nil), // 35: google.events.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfig
	(*Instance_ReadPoolConfig)(nil),              // 36: google.events.cloud.alloydb.v1.Instance.ReadPoolConfig
	nil,                                          // 37: google.events.cloud.alloydb.v1.Instance.LabelsEntry
	nil,                                          // 38: google.events.cloud.alloydb.v1.Instance.DatabaseFlagsEntry
	nil,                                          // 39: google.events.cloud.alloydb.v1.Instance.AnnotationsEntry
	nil,                                          // 40: google.events.cloud.alloydb.v1.Backup.LabelsEntry
	nil,                                          // 41: google.events.cloud.alloydb.v1.Backup.AnnotationsEntry
	(*durationpb.Duration)(nil),                  // 42: google.protobuf.Duration
	(*timestamppb.Timestamp)(nil),                // 43: google.protobuf.Timestamp
	(*timeofday.TimeOfDay)(nil),                  // 44: google.type.TimeOfDay
	(dayofweek.DayOfWeek)(0),                     // 45: google.type.DayOfWeek
}
var file_cloud_alloydb_v1_data_proto_depIdxs = []int32{
	1,  // 0: google.events.cloud.alloydb.v1.MigrationSource.source_type:type_name -> google.events.cloud.alloydb.v1.MigrationSource.MigrationSourceType
	2,  // 1: google.events.cloud.alloydb.v1.EncryptionInfo.encryption_type:type_name -> google.events.cloud.alloydb.v1.EncryptionInfo.Type
	3,  // 2: google.events.cloud.alloydb.v1.SslConfig.ssl_mode:type_name -> google.events.cloud.alloydb.v1.SslConfig.SslMode
	4,  // 3: google.events.cloud.alloydb.v1.SslConfig.ca_source:type_name -> google.events.cloud.alloydb.v1.SslConfig.CaSource
	25, // 4: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.weekly_schedule:type_name -> google.events.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule
	26, // 5: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.time_based_retention:type_name -> google.events.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention
	27, // 6: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.quantity_based_retention:type_name -> google.events.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetention
	42, // 7: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.backup_window:type_name -> google.protobuf.Duration
	14, // 8: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.encryption_config:type_name -> google.events.cloud.alloydb.v1.EncryptionConfig
	28, // 9: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.labels:type_name -> google.events.cloud.alloydb.v1.AutomatedBackupPolicy.LabelsEntry
	18, // 10: google.events.cloud.alloydb.v1.Cluster.backup_source:type_name -> google.events.cloud.alloydb.v1.BackupSource
	13, // 11: google.events.cloud.alloydb.v1.Cluster.migration_source:type_name -> google.events.cloud.alloydb.v1.MigrationSource
	43, // 12: google.events.cloud.alloydb.v1.Cluster.create_time:type_name -> google.protobuf.Timestamp
	43, // 13: google.events.cloud.alloydb.v1.Cluster.update_time:type_name -> google.protobuf.Timestamp
	43, // 14: google.events.cloud.alloydb.v1.Cluster.delete_time:type_name -> google.protobuf.Timestamp
	31, // 15: google.events.cloud.alloydb.v1.Cluster.labels:type_name -> google.events.cloud.alloydb.v1.Cluster.LabelsEntry
	5,  // 16: google.events.cloud.alloydb.v1.Cluster.state:type_name -> google.events.cloud.alloydb.v1.Cluster.State
	6,  // 17: google.events.cloud.alloydb.v1.Cluster.cluster_type:type_name -> google.events.cloud.alloydb.v1.Cluster.ClusterType
	0,  // 18: google.events.cloud.alloydb.v1.Cluster.database_version:type_name -> google.events.cloud.alloydb.v1.DatabaseVersion
	32, // 19: google.events.cloud.alloydb.v1.Cluster.annotations:type_name -> google.events.cloud.alloydb.v1.Cluster.AnnotationsEntry
	17, // 20: google.events.cloud.alloydb.v1.Cluster.automated_backup_policy:type_name -> google.events.cloud.alloydb.v1.AutomatedBackupPolicy
	16, // 21: google.events.cloud.alloydb.v1.Cluster.ssl_config:type_name -> google.events.cloud.alloydb.v1.SslConfig
	14, // 22: google.events.cloud.alloydb.v1.Cluster.encryption_config:type_name -> google.events.cloud.alloydb.v1.EncryptionConfig
	15, // 23: google.events.cloud.alloydb.v1.Cluster.encryption_info:type_name -> google.events.cloud.alloydb.v1.EncryptionInfo
	29, // 24: google.events.cloud.alloydb.v1.Cluster.secondary_config:type_name -> google.events.cloud.alloydb.v1.Cluster.SecondaryConfig
	30, // 25: google.events.cloud.alloydb.v1.Cluster.primary_config:type_name -> google.events.cloud.alloydb.v1.Cluster.PrimaryConfig
	43, // 26: google.events.cloud.alloydb.v1.Instance.create_time:type_name -> google.protobuf.Timestamp
	43, // 27: google.events.cloud.alloydb.v1.Instance.update_time:type_name -> google.protobuf.Timestamp
	43, // 28: google.events.cloud.alloydb.v1.Instance.delete_time:type_name -> google.protobuf.Timestamp
	37, // 29: google.events.cloud.alloydb.v1.Instance.labels:type_name -> google.events.cloud.alloydb.v1.Instance.LabelsEntry
	7,  // 30: google.events.cloud.alloydb.v1.Instance.state:type_name -> google.events.cloud.alloydb.v1.Instance.State
	8,  // 31: google.events.cloud.alloydb.v1.Instance.instance_type:type_name -> google.events.cloud.alloydb.v1.Instance.InstanceType
	33, // 32: google.events.cloud.alloydb.v1.Instance.machine_config:type_name -> google.events.cloud.alloydb.v1.Instance.MachineConfig
	9,  // 33: google.events.cloud.alloydb.v1.Instance.availability_type:type_name -> google.events.cloud.alloydb.v1.Instance.AvailabilityType
	38, // 34: google.events.cloud.alloydb.v1.Instance.database_flags:type_name -> google.events.cloud.alloydb.v1.Instance.DatabaseFlagsEntry
	34, // 35: google.events.cloud.alloydb.v1.Instance.writable_node:type_name -> google.events.cloud.alloydb.v1.Instance.Node
	34, // 36: google.events.cloud.alloydb.v1.Instance.nodes:type_name -> google.events.cloud.alloydb.v1.Instance.Node
	35, // 37: google.events.cloud.alloydb.v1.Instance.query_insights_config:type_name -> google.events.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfig
	36, // 38: google.events.cloud.alloydb.v1.Instance.read_pool_config:type_name -> google.events.cloud.alloydb.v1.Instance.ReadPoolConfig
	39, // 39: google.events.cloud.alloydb.v1.Instance.annotations:type_name -> google.events.cloud.alloydb.v1.Instance.AnnotationsEntry
	43, // 40: google.events.cloud.alloydb.v1.Backup.create_time:type_name -> google.protobuf.Timestamp
	43, // 41: google.events.cloud.alloydb.v1.Backup.update_time:type_name -> google.protobuf.Timestamp
	43, // 42: google.events.cloud.alloydb.v1.Backup.delete_time:type_name -> google.protobuf.Timestamp
	40, // 43: google.events.cloud.alloydb.v1.Backup.labels:type_name -> google.events.cloud.alloydb.v1.Backup.LabelsEntry
	10, // 44: google.events.cloud.alloydb.v1.Backup.state:type_name -> google.events.cloud.alloydb.v1.Backup.State
	11, // 45: google.events.cloud.alloydb.v1.Backup.type:type_name -> google.events.cloud.alloydb.v1.Backup.Type
	14, // 46: google.events.cloud.alloydb.v1.Backup.encryption_config:type_name -> google.events.cloud.alloydb.v1.EncryptionConfig
	15, // 47: google.events.cloud.alloydb.v1.Backup.encryption_info:type_name -> google.events.cloud.alloydb.v1.EncryptionInfo
	41, // 48: google.events.cloud.alloydb.v1.Backup.annotations:type_name -> google.events.cloud.alloydb.v1.Backup.AnnotationsEntry
	43, // 49: google.events.cloud.alloydb.v1.Backup.expiry_time:type_name -> google.protobuf.Timestamp
	20, // 50: google.events.cloud.alloydb.v1.InstanceEventData.payload:type_name -> google.events.cloud.alloydb.v1.Instance
	21, // 51: google.events.cloud.alloydb.v1.BackupEventData.payload:type_name -> google.events.cloud.alloydb.v1.Backup
	19, // 52: google.events.cloud.alloydb.v1.ClusterEventData.payload:type_name -> google.events.cloud.alloydb.v1.Cluster
	44, // 53: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule.start_times:type_name -> google.type.TimeOfDay
	45, // 54: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule.days_of_week:type_name -> google.type.DayOfWeek
	42, // 55: google.events.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention.retention_period:type_name -> google.protobuf.Duration
	56, // [56:56] is the sub-list for method output_type
	56, // [56:56] is the sub-list for method input_type
	56, // [56:56] is the sub-list for extension type_name
	56, // [56:56] is the sub-list for extension extendee
	0,  // [0:56] is the sub-list for field type_name
}

func init() { file_cloud_alloydb_v1_data_proto_init() }
func file_cloud_alloydb_v1_data_proto_init() {
	if File_cloud_alloydb_v1_data_proto != nil {
		return
	}
	file_cloud_alloydb_v1_data_proto_msgTypes[5].OneofWrappers = []any{
		(*AutomatedBackupPolicy_WeeklySchedule_)(nil),
		(*AutomatedBackupPolicy_TimeBasedRetention_)(nil),
		(*AutomatedBackupPolicy_QuantityBasedRetention_)(nil),
	}
	file_cloud_alloydb_v1_data_proto_msgTypes[7].OneofWrappers = []any{
		(*Cluster_BackupSource)(nil),
		(*Cluster_MigrationSource)(nil),
	}
	file_cloud_alloydb_v1_data_proto_msgTypes[10].OneofWrappers = []any{}
	file_cloud_alloydb_v1_data_proto_msgTypes[11].OneofWrappers = []any{}
	file_cloud_alloydb_v1_data_proto_msgTypes[12].OneofWrappers = []any{}
	file_cloud_alloydb_v1_data_proto_msgTypes[23].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cloud_alloydb_v1_data_proto_rawDesc), len(file_cloud_alloydb_v1_data_proto_rawDesc)),
			NumEnums:      12,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cloud_alloydb_v1_data_proto_goTypes,
		DependencyIndexes: file_cloud_alloydb_v1_data_proto_depIdxs,
		EnumInfos:         file_cloud_alloydb_v1_data_proto_enumTypes,
		MessageInfos:      file_cloud_alloydb_v1_data_proto_msgTypes,
	}.Build()
	File_cloud_alloydb_v1_data_proto = out.File
	file_cloud_alloydb_v1_data_proto_goTypes = nil
	file_cloud_alloydb_v1_data_proto_depIdxs = nil
}
