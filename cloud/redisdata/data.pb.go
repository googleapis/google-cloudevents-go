// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.6
// source: cloud/redis/v1/data.proto

package redisdata

import (
	dayofweek "google.golang.org/genproto/googleapis/type/dayofweek"
	timeofday "google.golang.org/genproto/googleapis/type/timeofday"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents the different states of a Redis instance.
type Instance_State int32

const (
	// Not set.
	Instance_STATE_UNSPECIFIED Instance_State = 0
	// Redis instance is being created.
	Instance_CREATING Instance_State = 1
	// Redis instance has been created and is fully usable.
	Instance_READY Instance_State = 2
	// Redis instance configuration is being updated. Certain kinds of updates
	// may cause the instance to become unusable while the update is in
	// progress.
	Instance_UPDATING Instance_State = 3
	// Redis instance is being deleted.
	Instance_DELETING Instance_State = 4
	// Redis instance is being repaired and may be unusable.
	Instance_REPAIRING Instance_State = 5
	// Maintenance is being performed on this Redis instance.
	Instance_MAINTENANCE Instance_State = 6
	// Redis instance is importing data (availability may be affected).
	Instance_IMPORTING Instance_State = 8
	// Redis instance is failing over (availability may be affected).
	Instance_FAILING_OVER Instance_State = 9
)

// Enum value maps for Instance_State.
var (
	Instance_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "CREATING",
		2: "READY",
		3: "UPDATING",
		4: "DELETING",
		5: "REPAIRING",
		6: "MAINTENANCE",
		8: "IMPORTING",
		9: "FAILING_OVER",
	}
	Instance_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"CREATING":          1,
		"READY":             2,
		"UPDATING":          3,
		"DELETING":          4,
		"REPAIRING":         5,
		"MAINTENANCE":       6,
		"IMPORTING":         8,
		"FAILING_OVER":      9,
	}
)

func (x Instance_State) Enum() *Instance_State {
	p := new(Instance_State)
	*p = x
	return p
}

func (x Instance_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_State) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[0].Descriptor()
}

func (Instance_State) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[0]
}

func (x Instance_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_State.Descriptor instead.
func (Instance_State) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 0}
}

// Available service tiers to choose from
type Instance_Tier int32

const (
	// Not set.
	Instance_TIER_UNSPECIFIED Instance_Tier = 0
	// BASIC tier: standalone instance
	Instance_BASIC Instance_Tier = 1
	// STANDARD_HA tier: highly available primary/replica instances
	Instance_STANDARD_HA Instance_Tier = 3
)

// Enum value maps for Instance_Tier.
var (
	Instance_Tier_name = map[int32]string{
		0: "TIER_UNSPECIFIED",
		1: "BASIC",
		3: "STANDARD_HA",
	}
	Instance_Tier_value = map[string]int32{
		"TIER_UNSPECIFIED": 0,
		"BASIC":            1,
		"STANDARD_HA":      3,
	}
)

func (x Instance_Tier) Enum() *Instance_Tier {
	p := new(Instance_Tier)
	*p = x
	return p
}

func (x Instance_Tier) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_Tier) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[1].Descriptor()
}

func (Instance_Tier) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[1]
}

func (x Instance_Tier) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_Tier.Descriptor instead.
func (Instance_Tier) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 1}
}

// Available connection modes.
type Instance_ConnectMode int32

const (
	// Not set.
	Instance_CONNECT_MODE_UNSPECIFIED Instance_ConnectMode = 0
	// Connect via direct peering to the Memorystore for Redis hosted service.
	Instance_DIRECT_PEERING Instance_ConnectMode = 1
	// Connect your Memorystore for Redis instance using Private Service
	// Access. Private services access provides an IP address range for multiple
	// Google Cloud services, including Memorystore.
	Instance_PRIVATE_SERVICE_ACCESS Instance_ConnectMode = 2
)

// Enum value maps for Instance_ConnectMode.
var (
	Instance_ConnectMode_name = map[int32]string{
		0: "CONNECT_MODE_UNSPECIFIED",
		1: "DIRECT_PEERING",
		2: "PRIVATE_SERVICE_ACCESS",
	}
	Instance_ConnectMode_value = map[string]int32{
		"CONNECT_MODE_UNSPECIFIED": 0,
		"DIRECT_PEERING":           1,
		"PRIVATE_SERVICE_ACCESS":   2,
	}
)

func (x Instance_ConnectMode) Enum() *Instance_ConnectMode {
	p := new(Instance_ConnectMode)
	*p = x
	return p
}

func (x Instance_ConnectMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_ConnectMode) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[2].Descriptor()
}

func (Instance_ConnectMode) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[2]
}

func (x Instance_ConnectMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_ConnectMode.Descriptor instead.
func (Instance_ConnectMode) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 2}
}

// Available TLS modes.
type Instance_TransitEncryptionMode int32

const (
	// Not set.
	Instance_TRANSIT_ENCRYPTION_MODE_UNSPECIFIED Instance_TransitEncryptionMode = 0
	// Client to Server traffic encryption enabled with server authentication.
	Instance_SERVER_AUTHENTICATION Instance_TransitEncryptionMode = 1
	// TLS is disabled for the instance.
	Instance_DISABLED Instance_TransitEncryptionMode = 2
)

// Enum value maps for Instance_TransitEncryptionMode.
var (
	Instance_TransitEncryptionMode_name = map[int32]string{
		0: "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED",
		1: "SERVER_AUTHENTICATION",
		2: "DISABLED",
	}
	Instance_TransitEncryptionMode_value = map[string]int32{
		"TRANSIT_ENCRYPTION_MODE_UNSPECIFIED": 0,
		"SERVER_AUTHENTICATION":               1,
		"DISABLED":                            2,
	}
)

func (x Instance_TransitEncryptionMode) Enum() *Instance_TransitEncryptionMode {
	p := new(Instance_TransitEncryptionMode)
	*p = x
	return p
}

func (x Instance_TransitEncryptionMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_TransitEncryptionMode) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[3].Descriptor()
}

func (Instance_TransitEncryptionMode) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[3]
}

func (x Instance_TransitEncryptionMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_TransitEncryptionMode.Descriptor instead.
func (Instance_TransitEncryptionMode) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 3}
}

// Read replicas mode.
type Instance_ReadReplicasMode int32

const (
	// If not set, Memorystore Redis backend will default to
	// READ_REPLICAS_DISABLED.
	Instance_READ_REPLICAS_MODE_UNSPECIFIED Instance_ReadReplicasMode = 0
	// If disabled, read endpoint will not be provided and the instance cannot
	// scale up or down the number of replicas.
	Instance_READ_REPLICAS_DISABLED Instance_ReadReplicasMode = 1
	// If enabled, read endpoint will be provided and the instance can scale
	// up and down the number of replicas. Not valid for basic tier.
	Instance_READ_REPLICAS_ENABLED Instance_ReadReplicasMode = 2
)

// Enum value maps for Instance_ReadReplicasMode.
var (
	Instance_ReadReplicasMode_name = map[int32]string{
		0: "READ_REPLICAS_MODE_UNSPECIFIED",
		1: "READ_REPLICAS_DISABLED",
		2: "READ_REPLICAS_ENABLED",
	}
	Instance_ReadReplicasMode_value = map[string]int32{
		"READ_REPLICAS_MODE_UNSPECIFIED": 0,
		"READ_REPLICAS_DISABLED":         1,
		"READ_REPLICAS_ENABLED":          2,
	}
)

func (x Instance_ReadReplicasMode) Enum() *Instance_ReadReplicasMode {
	p := new(Instance_ReadReplicasMode)
	*p = x
	return p
}

func (x Instance_ReadReplicasMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_ReadReplicasMode) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[4].Descriptor()
}

func (Instance_ReadReplicasMode) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[4]
}

func (x Instance_ReadReplicasMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_ReadReplicasMode.Descriptor instead.
func (Instance_ReadReplicasMode) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 4}
}

// Possible reasons for the instance to be in a "SUSPENDED" state.
type Instance_SuspensionReason int32

const (
	// Not set.
	Instance_SUSPENSION_REASON_UNSPECIFIED Instance_SuspensionReason = 0
	// Something wrong with the CMEK key provided by customer.
	Instance_CUSTOMER_MANAGED_KEY_ISSUE Instance_SuspensionReason = 1
)

// Enum value maps for Instance_SuspensionReason.
var (
	Instance_SuspensionReason_name = map[int32]string{
		0: "SUSPENSION_REASON_UNSPECIFIED",
		1: "CUSTOMER_MANAGED_KEY_ISSUE",
	}
	Instance_SuspensionReason_value = map[string]int32{
		"SUSPENSION_REASON_UNSPECIFIED": 0,
		"CUSTOMER_MANAGED_KEY_ISSUE":    1,
	}
)

func (x Instance_SuspensionReason) Enum() *Instance_SuspensionReason {
	p := new(Instance_SuspensionReason)
	*p = x
	return p
}

func (x Instance_SuspensionReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Instance_SuspensionReason) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[5].Descriptor()
}

func (Instance_SuspensionReason) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[5]
}

func (x Instance_SuspensionReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Instance_SuspensionReason.Descriptor instead.
func (Instance_SuspensionReason) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1, 5}
}

// Available Persistence modes.
type PersistenceConfig_PersistenceMode int32

const (
	// Not set.
	PersistenceConfig_PERSISTENCE_MODE_UNSPECIFIED PersistenceConfig_PersistenceMode = 0
	// Persistence is disabled for the instance,
	// and any existing snapshots are deleted.
	PersistenceConfig_DISABLED PersistenceConfig_PersistenceMode = 1
	// RDB based Persistence is enabled.
	PersistenceConfig_RDB PersistenceConfig_PersistenceMode = 2
)

// Enum value maps for PersistenceConfig_PersistenceMode.
var (
	PersistenceConfig_PersistenceMode_name = map[int32]string{
		0: "PERSISTENCE_MODE_UNSPECIFIED",
		1: "DISABLED",
		2: "RDB",
	}
	PersistenceConfig_PersistenceMode_value = map[string]int32{
		"PERSISTENCE_MODE_UNSPECIFIED": 0,
		"DISABLED":                     1,
		"RDB":                          2,
	}
)

func (x PersistenceConfig_PersistenceMode) Enum() *PersistenceConfig_PersistenceMode {
	p := new(PersistenceConfig_PersistenceMode)
	*p = x
	return p
}

func (x PersistenceConfig_PersistenceMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PersistenceConfig_PersistenceMode) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[6].Descriptor()
}

func (PersistenceConfig_PersistenceMode) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[6]
}

func (x PersistenceConfig_PersistenceMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PersistenceConfig_PersistenceMode.Descriptor instead.
func (PersistenceConfig_PersistenceMode) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{2, 0}
}

// Available snapshot periods for scheduling.
type PersistenceConfig_SnapshotPeriod int32

const (
	// Not set.
	PersistenceConfig_SNAPSHOT_PERIOD_UNSPECIFIED PersistenceConfig_SnapshotPeriod = 0
	// Snapshot every 1 hour.
	PersistenceConfig_ONE_HOUR PersistenceConfig_SnapshotPeriod = 3
	// Snapshot every 6 hours.
	PersistenceConfig_SIX_HOURS PersistenceConfig_SnapshotPeriod = 4
	// Snapshot every 12 hours.
	PersistenceConfig_TWELVE_HOURS PersistenceConfig_SnapshotPeriod = 5
	// Snapshot every 24 hours.
	PersistenceConfig_TWENTY_FOUR_HOURS PersistenceConfig_SnapshotPeriod = 6
)

// Enum value maps for PersistenceConfig_SnapshotPeriod.
var (
	PersistenceConfig_SnapshotPeriod_name = map[int32]string{
		0: "SNAPSHOT_PERIOD_UNSPECIFIED",
		3: "ONE_HOUR",
		4: "SIX_HOURS",
		5: "TWELVE_HOURS",
		6: "TWENTY_FOUR_HOURS",
	}
	PersistenceConfig_SnapshotPeriod_value = map[string]int32{
		"SNAPSHOT_PERIOD_UNSPECIFIED": 0,
		"ONE_HOUR":                    3,
		"SIX_HOURS":                   4,
		"TWELVE_HOURS":                5,
		"TWENTY_FOUR_HOURS":           6,
	}
)

func (x PersistenceConfig_SnapshotPeriod) Enum() *PersistenceConfig_SnapshotPeriod {
	p := new(PersistenceConfig_SnapshotPeriod)
	*p = x
	return p
}

func (x PersistenceConfig_SnapshotPeriod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PersistenceConfig_SnapshotPeriod) Descriptor() protoreflect.EnumDescriptor {
	return file_cloud_redis_v1_data_proto_enumTypes[7].Descriptor()
}

func (PersistenceConfig_SnapshotPeriod) Type() protoreflect.EnumType {
	return &file_cloud_redis_v1_data_proto_enumTypes[7]
}

func (x PersistenceConfig_SnapshotPeriod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PersistenceConfig_SnapshotPeriod.Descriptor instead.
func (PersistenceConfig_SnapshotPeriod) EnumDescriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{2, 1}
}

// Node specific properties.
type NodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. Node identifying string. e.g. 'node-0', 'node-1'
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Output only. Location of the node.
	Zone          string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{0}
}

func (x *NodeInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *NodeInfo) GetZone() string {
	if x != nil {
		return x.Zone
	}
	return ""
}

// A Memorystore for Redis instance.
type Instance struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. Unique name of the resource in this scope including project and
	// location using the form:
	//
	//	`projects/{project_id}/locations/{location_id}/instances/{instance_id}`
	//
	// Note: Redis instances are managed and addressed at regional level so
	// location_id here refers to a GCP region; however, users may choose which
	// specific zone (or collection of zones for cross-zone instances) an instance
	// should be provisioned in. Refer to
	// [location_id][google.cloud.redis.v1.Instance.location_id] and
	// [alternative_location_id][google.cloud.redis.v1.Instance.alternative_location_id]
	// fields for more details.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An arbitrary and optional user-provided name for the instance.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Resource labels to represent user provided metadata
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Optional. The zone where the instance will be provisioned. If not provided,
	// the service will choose a zone from the specified region for the instance.
	// For standard tier, additional nodes will be added across multiple zones for
	// protection against zonal failures. If specified, at least one node will be
	// provisioned in this zone.
	LocationId string `protobuf:"bytes,4,opt,name=location_id,json=locationId,proto3" json:"location_id,omitempty"`
	// Optional. If specified, at least one node will be provisioned in this zone
	// in addition to the zone specified in location_id. Only applicable to
	// standard tier. If provided, it must be a different zone from the one
	// provided in [location_id]. Additional nodes beyond the first 2 will be
	// placed in zones selected by the service.
	AlternativeLocationId string `protobuf:"bytes,5,opt,name=alternative_location_id,json=alternativeLocationId,proto3" json:"alternative_location_id,omitempty"`
	// Optional. The version of Redis software.
	// If not provided, latest supported version will be used. Currently, the
	// supported values are:
	//
	//   - `REDIS_3_2` for Redis 3.2 compatibility
	//   - `REDIS_4_0` for Redis 4.0 compatibility (default)
	//   - `REDIS_5_0` for Redis 5.0 compatibility
	//   - `REDIS_6_X` for Redis 6.x compatibility
	RedisVersion string `protobuf:"bytes,7,opt,name=redis_version,json=redisVersion,proto3" json:"redis_version,omitempty"`
	// Optional. For DIRECT_PEERING mode, the CIDR range of internal addresses
	// that are reserved for this instance. Range must
	// be unique and non-overlapping with existing subnets in an authorized
	// network. For PRIVATE_SERVICE_ACCESS mode, the name of one allocated IP
	// address ranges associated with this private service access connection.
	// If not provided, the service will choose an unused /29 block, for
	// example, 10.0.0.0/29 or 192.168.0.0/29.  For READ_REPLICAS_ENABLED
	// the default block size is /28.
	ReservedIpRange string `protobuf:"bytes,9,opt,name=reserved_ip_range,json=reservedIpRange,proto3" json:"reserved_ip_range,omitempty"`
	// Optional. Additional IP range for node placement. Required when enabling
	// read replicas on an existing instance. For DIRECT_PEERING mode value must
	// be a CIDR range of size /28, or "auto". For PRIVATE_SERVICE_ACCESS mode
	// value must be the name of an allocated address range associated with the
	// private service access connection, or "auto".
	SecondaryIpRange string `protobuf:"bytes,30,opt,name=secondary_ip_range,json=secondaryIpRange,proto3" json:"secondary_ip_range,omitempty"`
	// Output only. Hostname or IP address of the exposed Redis endpoint used by
	// clients to connect to the service.
	Host string `protobuf:"bytes,10,opt,name=host,proto3" json:"host,omitempty"`
	// Output only. The port number of the exposed Redis endpoint.
	Port int32 `protobuf:"varint,11,opt,name=port,proto3" json:"port,omitempty"`
	// Output only. The current zone where the Redis primary node is located. In
	// basic tier, this will always be the same as [location_id]. In
	// standard tier, this can be the zone of any node in the instance.
	CurrentLocationId string `protobuf:"bytes,12,opt,name=current_location_id,json=currentLocationId,proto3" json:"current_location_id,omitempty"`
	// Output only. The time the instance was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. The current state of this instance.
	State Instance_State `protobuf:"varint,14,opt,name=state,proto3,enum=google.events.cloud.redis.v1.Instance_State" json:"state,omitempty"`
	// Output only. Additional information about the current status of this
	// instance, if available.
	StatusMessage string `protobuf:"bytes,15,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
	// Optional. Redis configuration parameters, according to
	// http://redis.io/topics/config. Currently, the only supported parameters
	// are:
	//
	//	Redis version 3.2 and newer:
	//
	//	*   maxmemory-policy
	//	*   notify-keyspace-events
	//
	//	Redis version 4.0 and newer:
	//
	//	*   activedefrag
	//	*   lfu-decay-time
	//	*   lfu-log-factor
	//	*   maxmemory-gb
	//
	//	Redis version 5.0 and newer:
	//
	//	*   stream-node-max-bytes
	//	*   stream-node-max-entries
	RedisConfigs map[string]string `protobuf:"bytes,16,rep,name=redis_configs,json=redisConfigs,proto3" json:"redis_configs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Required. The service tier of the instance.
	Tier Instance_Tier `protobuf:"varint,17,opt,name=tier,proto3,enum=google.events.cloud.redis.v1.Instance_Tier" json:"tier,omitempty"`
	// Required. Redis memory size in GiB.
	MemorySizeGb int32 `protobuf:"varint,18,opt,name=memory_size_gb,json=memorySizeGb,proto3" json:"memory_size_gb,omitempty"`
	// Optional. The full name of the Google Compute Engine
	// [network](https://cloud.google.com/vpc/docs/vpc) to which the
	// instance is connected. If left unspecified, the `default` network
	// will be used.
	AuthorizedNetwork string `protobuf:"bytes,20,opt,name=authorized_network,json=authorizedNetwork,proto3" json:"authorized_network,omitempty"`
	// Output only. Cloud IAM identity used by import / export operations to
	// transfer data to/from Cloud Storage. Format is
	// "serviceAccount:<service_account_email>". The value may change over time
	// for a given instance so should be checked before each import/export
	// operation.
	PersistenceIamIdentity string `protobuf:"bytes,21,opt,name=persistence_iam_identity,json=persistenceIamIdentity,proto3" json:"persistence_iam_identity,omitempty"`
	// Optional. The network connect mode of the Redis instance.
	// If not provided, the connect mode defaults to DIRECT_PEERING.
	ConnectMode Instance_ConnectMode `protobuf:"varint,22,opt,name=connect_mode,json=connectMode,proto3,enum=google.events.cloud.redis.v1.Instance_ConnectMode" json:"connect_mode,omitempty"`
	// Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If
	// set to "true" AUTH is enabled on the instance. Default value is "false"
	// meaning AUTH is disabled.
	AuthEnabled bool `protobuf:"varint,23,opt,name=auth_enabled,json=authEnabled,proto3" json:"auth_enabled,omitempty"`
	// Output only. List of server CA certificates for the instance.
	ServerCaCerts []*TlsCertificate `protobuf:"bytes,25,rep,name=server_ca_certs,json=serverCaCerts,proto3" json:"server_ca_certs,omitempty"`
	// Optional. The TLS mode of the Redis instance.
	// If not provided, TLS is disabled for the instance.
	TransitEncryptionMode Instance_TransitEncryptionMode `protobuf:"varint,26,opt,name=transit_encryption_mode,json=transitEncryptionMode,proto3,enum=google.events.cloud.redis.v1.Instance_TransitEncryptionMode" json:"transit_encryption_mode,omitempty"`
	// Optional. The maintenance policy for the instance. If not provided,
	// maintenance events can be performed at any time.
	MaintenancePolicy *MaintenancePolicy `protobuf:"bytes,27,opt,name=maintenance_policy,json=maintenancePolicy,proto3" json:"maintenance_policy,omitempty"`
	// Output only. Date and time of upcoming maintenance events which have been
	// scheduled.
	MaintenanceSchedule *MaintenanceSchedule `protobuf:"bytes,28,opt,name=maintenance_schedule,json=maintenanceSchedule,proto3" json:"maintenance_schedule,omitempty"`
	// Optional. The number of replica nodes. The valid range for the Standard
	// Tier with read replicas enabled is [1-5] and defaults to 2. If read
	// replicas are not enabled for a Standard Tier instance, the only valid value
	// is 1 and the default is 1. The valid value for basic tier is 0 and the
	// default is also 0.
	ReplicaCount int32 `protobuf:"varint,31,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// Output only. Info per node.
	Nodes []*NodeInfo `protobuf:"bytes,32,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Output only. Hostname or IP address of the exposed readonly Redis
	// endpoint. Standard tier only. Targets all healthy replica nodes in
	// instance. Replication is asynchronous and replica nodes will exhibit some
	// lag behind the primary. Write requests must target 'host'.
	ReadEndpoint string `protobuf:"bytes,33,opt,name=read_endpoint,json=readEndpoint,proto3" json:"read_endpoint,omitempty"`
	// Output only. The port number of the exposed readonly redis
	// endpoint. Standard tier only. Write requests should target 'port'.
	ReadEndpointPort int32 `protobuf:"varint,34,opt,name=read_endpoint_port,json=readEndpointPort,proto3" json:"read_endpoint_port,omitempty"`
	// Optional. Read replicas mode for the instance. Defaults to
	// READ_REPLICAS_DISABLED.
	ReadReplicasMode Instance_ReadReplicasMode `protobuf:"varint,35,opt,name=read_replicas_mode,json=readReplicasMode,proto3,enum=google.events.cloud.redis.v1.Instance_ReadReplicasMode" json:"read_replicas_mode,omitempty"`
	// Optional. The KMS key reference that the customer provides when trying to
	// create the instance.
	CustomerManagedKey string `protobuf:"bytes,36,opt,name=customer_managed_key,json=customerManagedKey,proto3" json:"customer_managed_key,omitempty"`
	// Optional. Persistence configuration parameters
	PersistenceConfig *PersistenceConfig `protobuf:"bytes,37,opt,name=persistence_config,json=persistenceConfig,proto3" json:"persistence_config,omitempty"`
	// Optional. reasons that causes instance in "SUSPENDED" state.
	SuspensionReasons []Instance_SuspensionReason `protobuf:"varint,38,rep,packed,name=suspension_reasons,json=suspensionReasons,proto3,enum=google.events.cloud.redis.v1.Instance_SuspensionReason" json:"suspension_reasons,omitempty"`
	// Optional. The self service update maintenance version.
	// The version is date based such as "20210712_00_00".
	MaintenanceVersion string `protobuf:"bytes,39,opt,name=maintenance_version,json=maintenanceVersion,proto3" json:"maintenance_version,omitempty"`
	// Optional. The available maintenance versions that an instance could update
	// to.
	AvailableMaintenanceVersions []string `protobuf:"bytes,40,rep,name=available_maintenance_versions,json=availableMaintenanceVersions,proto3" json:"available_maintenance_versions,omitempty"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *Instance) Reset() {
	*x = Instance{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance) ProtoMessage() {}

func (x *Instance) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance.ProtoReflect.Descriptor instead.
func (*Instance) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{1}
}

func (x *Instance) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Instance) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *Instance) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Instance) GetLocationId() string {
	if x != nil {
		return x.LocationId
	}
	return ""
}

func (x *Instance) GetAlternativeLocationId() string {
	if x != nil {
		return x.AlternativeLocationId
	}
	return ""
}

func (x *Instance) GetRedisVersion() string {
	if x != nil {
		return x.RedisVersion
	}
	return ""
}

func (x *Instance) GetReservedIpRange() string {
	if x != nil {
		return x.ReservedIpRange
	}
	return ""
}

func (x *Instance) GetSecondaryIpRange() string {
	if x != nil {
		return x.SecondaryIpRange
	}
	return ""
}

func (x *Instance) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *Instance) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *Instance) GetCurrentLocationId() string {
	if x != nil {
		return x.CurrentLocationId
	}
	return ""
}

func (x *Instance) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Instance) GetState() Instance_State {
	if x != nil {
		return x.State
	}
	return Instance_STATE_UNSPECIFIED
}

func (x *Instance) GetStatusMessage() string {
	if x != nil {
		return x.StatusMessage
	}
	return ""
}

func (x *Instance) GetRedisConfigs() map[string]string {
	if x != nil {
		return x.RedisConfigs
	}
	return nil
}

func (x *Instance) GetTier() Instance_Tier {
	if x != nil {
		return x.Tier
	}
	return Instance_TIER_UNSPECIFIED
}

func (x *Instance) GetMemorySizeGb() int32 {
	if x != nil {
		return x.MemorySizeGb
	}
	return 0
}

func (x *Instance) GetAuthorizedNetwork() string {
	if x != nil {
		return x.AuthorizedNetwork
	}
	return ""
}

func (x *Instance) GetPersistenceIamIdentity() string {
	if x != nil {
		return x.PersistenceIamIdentity
	}
	return ""
}

func (x *Instance) GetConnectMode() Instance_ConnectMode {
	if x != nil {
		return x.ConnectMode
	}
	return Instance_CONNECT_MODE_UNSPECIFIED
}

func (x *Instance) GetAuthEnabled() bool {
	if x != nil {
		return x.AuthEnabled
	}
	return false
}

func (x *Instance) GetServerCaCerts() []*TlsCertificate {
	if x != nil {
		return x.ServerCaCerts
	}
	return nil
}

func (x *Instance) GetTransitEncryptionMode() Instance_TransitEncryptionMode {
	if x != nil {
		return x.TransitEncryptionMode
	}
	return Instance_TRANSIT_ENCRYPTION_MODE_UNSPECIFIED
}

func (x *Instance) GetMaintenancePolicy() *MaintenancePolicy {
	if x != nil {
		return x.MaintenancePolicy
	}
	return nil
}

func (x *Instance) GetMaintenanceSchedule() *MaintenanceSchedule {
	if x != nil {
		return x.MaintenanceSchedule
	}
	return nil
}

func (x *Instance) GetReplicaCount() int32 {
	if x != nil {
		return x.ReplicaCount
	}
	return 0
}

func (x *Instance) GetNodes() []*NodeInfo {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *Instance) GetReadEndpoint() string {
	if x != nil {
		return x.ReadEndpoint
	}
	return ""
}

func (x *Instance) GetReadEndpointPort() int32 {
	if x != nil {
		return x.ReadEndpointPort
	}
	return 0
}

func (x *Instance) GetReadReplicasMode() Instance_ReadReplicasMode {
	if x != nil {
		return x.ReadReplicasMode
	}
	return Instance_READ_REPLICAS_MODE_UNSPECIFIED
}

func (x *Instance) GetCustomerManagedKey() string {
	if x != nil {
		return x.CustomerManagedKey
	}
	return ""
}

func (x *Instance) GetPersistenceConfig() *PersistenceConfig {
	if x != nil {
		return x.PersistenceConfig
	}
	return nil
}

func (x *Instance) GetSuspensionReasons() []Instance_SuspensionReason {
	if x != nil {
		return x.SuspensionReasons
	}
	return nil
}

func (x *Instance) GetMaintenanceVersion() string {
	if x != nil {
		return x.MaintenanceVersion
	}
	return ""
}

func (x *Instance) GetAvailableMaintenanceVersions() []string {
	if x != nil {
		return x.AvailableMaintenanceVersions
	}
	return nil
}

// Configuration of the persistence functionality.
type PersistenceConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. Controls whether Persistence features are enabled.
	// If not provided, the existing value will be used.
	PersistenceMode PersistenceConfig_PersistenceMode `protobuf:"varint,1,opt,name=persistence_mode,json=persistenceMode,proto3,enum=google.events.cloud.redis.v1.PersistenceConfig_PersistenceMode" json:"persistence_mode,omitempty"`
	// Optional. Period between RDB snapshots. Snapshots will be attempted every
	// period starting from the provided snapshot start time. For example, a start
	// time of 01/01/2033 06:45 and SIX_HOURS snapshot period will do nothing
	// until 01/01/2033, and then trigger snapshots every day at 06:45, 12:45,
	// 18:45, and 00:45 the next day, and so on. If not provided,
	// TWENTY_FOUR_HOURS will be used as default.
	RdbSnapshotPeriod PersistenceConfig_SnapshotPeriod `protobuf:"varint,2,opt,name=rdb_snapshot_period,json=rdbSnapshotPeriod,proto3,enum=google.events.cloud.redis.v1.PersistenceConfig_SnapshotPeriod" json:"rdb_snapshot_period,omitempty"`
	// Output only. The next time that a snapshot attempt is scheduled to occur.
	RdbNextSnapshotTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=rdb_next_snapshot_time,json=rdbNextSnapshotTime,proto3" json:"rdb_next_snapshot_time,omitempty"`
	// Optional. Date and time that the first snapshot was/will be attempted, and
	// to which future snapshots will be aligned. If not provided, the current
	// time will be used.
	RdbSnapshotStartTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=rdb_snapshot_start_time,json=rdbSnapshotStartTime,proto3" json:"rdb_snapshot_start_time,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *PersistenceConfig) Reset() {
	*x = PersistenceConfig{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PersistenceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PersistenceConfig) ProtoMessage() {}

func (x *PersistenceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PersistenceConfig.ProtoReflect.Descriptor instead.
func (*PersistenceConfig) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{2}
}

func (x *PersistenceConfig) GetPersistenceMode() PersistenceConfig_PersistenceMode {
	if x != nil {
		return x.PersistenceMode
	}
	return PersistenceConfig_PERSISTENCE_MODE_UNSPECIFIED
}

func (x *PersistenceConfig) GetRdbSnapshotPeriod() PersistenceConfig_SnapshotPeriod {
	if x != nil {
		return x.RdbSnapshotPeriod
	}
	return PersistenceConfig_SNAPSHOT_PERIOD_UNSPECIFIED
}

func (x *PersistenceConfig) GetRdbNextSnapshotTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RdbNextSnapshotTime
	}
	return nil
}

func (x *PersistenceConfig) GetRdbSnapshotStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RdbSnapshotStartTime
	}
	return nil
}

// Maintenance policy for an instance.
type MaintenancePolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The time when the policy was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. The time when the policy was last updated.
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Optional. Description of what this policy is for. Create/Update methods
	// return INVALID_ARGUMENT if the length is greater than 512.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Optional. Maintenance window that is applied to resources covered by this
	// policy. Minimum 1. For the current version, the maximum number of
	// weekly_window is expected to be one.
	WeeklyMaintenanceWindow []*WeeklyMaintenanceWindow `protobuf:"bytes,4,rep,name=weekly_maintenance_window,json=weeklyMaintenanceWindow,proto3" json:"weekly_maintenance_window,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *MaintenancePolicy) Reset() {
	*x = MaintenancePolicy{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MaintenancePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaintenancePolicy) ProtoMessage() {}

func (x *MaintenancePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MaintenancePolicy.ProtoReflect.Descriptor instead.
func (*MaintenancePolicy) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{3}
}

func (x *MaintenancePolicy) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *MaintenancePolicy) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *MaintenancePolicy) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *MaintenancePolicy) GetWeeklyMaintenanceWindow() []*WeeklyMaintenanceWindow {
	if x != nil {
		return x.WeeklyMaintenanceWindow
	}
	return nil
}

// Time window in which disruptive maintenance updates occur. Non-disruptive
// updates can occur inside or outside this window.
type WeeklyMaintenanceWindow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. The day of week that maintenance updates occur.
	Day dayofweek.DayOfWeek `protobuf:"varint,1,opt,name=day,proto3,enum=google.type.DayOfWeek" json:"day,omitempty"`
	// Required. Start time of the window in UTC time.
	StartTime *timeofday.TimeOfDay `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Output only. Duration of the maintenance window. The current window is
	// fixed at 1 hour.
	Duration      *durationpb.Duration `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WeeklyMaintenanceWindow) Reset() {
	*x = WeeklyMaintenanceWindow{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WeeklyMaintenanceWindow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WeeklyMaintenanceWindow) ProtoMessage() {}

func (x *WeeklyMaintenanceWindow) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WeeklyMaintenanceWindow.ProtoReflect.Descriptor instead.
func (*WeeklyMaintenanceWindow) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{4}
}

func (x *WeeklyMaintenanceWindow) GetDay() dayofweek.DayOfWeek {
	if x != nil {
		return x.Day
	}
	return dayofweek.DayOfWeek(0)
}

func (x *WeeklyMaintenanceWindow) GetStartTime() *timeofday.TimeOfDay {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *WeeklyMaintenanceWindow) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

// Upcoming maintenance schedule. If no maintenance is scheduled, fields are not
// populated.
type MaintenanceSchedule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Output only. The start time of any upcoming scheduled maintenance for this
	// instance.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Output only. The end time of any upcoming scheduled maintenance for this
	// instance.
	EndTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// If the scheduled maintenance can be rescheduled, default is true.
	CanReschedule bool `protobuf:"varint,3,opt,name=can_reschedule,json=canReschedule,proto3" json:"can_reschedule,omitempty"`
	// Output only. The deadline that the maintenance schedule start time can not
	// go beyond, including reschedule.
	ScheduleDeadlineTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=schedule_deadline_time,json=scheduleDeadlineTime,proto3" json:"schedule_deadline_time,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *MaintenanceSchedule) Reset() {
	*x = MaintenanceSchedule{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MaintenanceSchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaintenanceSchedule) ProtoMessage() {}

func (x *MaintenanceSchedule) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MaintenanceSchedule.ProtoReflect.Descriptor instead.
func (*MaintenanceSchedule) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{5}
}

func (x *MaintenanceSchedule) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *MaintenanceSchedule) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *MaintenanceSchedule) GetCanReschedule() bool {
	if x != nil {
		return x.CanReschedule
	}
	return false
}

func (x *MaintenanceSchedule) GetScheduleDeadlineTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduleDeadlineTime
	}
	return nil
}

// TlsCertificate Resource
type TlsCertificate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Serial number, as extracted from the certificate.
	SerialNumber string `protobuf:"bytes,1,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	// Output only. The time when the certificate was created in [RFC
	// 3339](https://tools.ietf.org/html/rfc3339) format, for example
	// `2020-05-18T00:00:00.094Z`.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Output only. The time when the certificate expires in [RFC
	// 3339](https://tools.ietf.org/html/rfc3339) format, for example
	// `2020-05-18T00:00:00.094Z`.
	ExpireTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
	// Sha1 Fingerprint of the certificate.
	Sha1Fingerprint string `protobuf:"bytes,5,opt,name=sha1_fingerprint,json=sha1Fingerprint,proto3" json:"sha1_fingerprint,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TlsCertificate) Reset() {
	*x = TlsCertificate{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsCertificate) ProtoMessage() {}

func (x *TlsCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsCertificate.ProtoReflect.Descriptor instead.
func (*TlsCertificate) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{6}
}

func (x *TlsCertificate) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *TlsCertificate) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *TlsCertificate) GetExpireTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpireTime
	}
	return nil
}

func (x *TlsCertificate) GetSha1Fingerprint() string {
	if x != nil {
		return x.Sha1Fingerprint
	}
	return ""
}

// The data within all Instance events.
type InstanceEventData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional. The Instance event payload. Unset for deletion events.
	Payload       *Instance `protobuf:"bytes,1,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstanceEventData) Reset() {
	*x = InstanceEventData{}
	mi := &file_cloud_redis_v1_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceEventData) ProtoMessage() {}

func (x *InstanceEventData) ProtoReflect() protoreflect.Message {
	mi := &file_cloud_redis_v1_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceEventData.ProtoReflect.Descriptor instead.
func (*InstanceEventData) Descriptor() ([]byte, []int) {
	return file_cloud_redis_v1_data_proto_rawDescGZIP(), []int{7}
}

func (x *InstanceEventData) GetPayload() *Instance {
	if x != nil {
		return x.Payload
	}
	return nil
}

var File_cloud_redis_v1_data_proto protoreflect.FileDescriptor

const file_cloud_redis_v1_data_proto_rawDesc = "" +
	"\n" +
	"\x19cloud/redis/v1/data.proto\x12\x1cgoogle.events.cloud.redis.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/type/dayofweek.proto\x1a\x1bgoogle/type/timeofday.proto\".\n" +
	"\bNodeInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04zone\x18\x02 \x01(\tR\x04zone\"\x89\x16\n" +
	"\bInstance\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x02 \x01(\tR\vdisplayName\x12J\n" +
	"\x06labels\x18\x03 \x03(\v22.google.events.cloud.redis.v1.Instance.LabelsEntryR\x06labels\x12\x1f\n" +
	"\vlocation_id\x18\x04 \x01(\tR\n" +
	"locationId\x126\n" +
	"\x17alternative_location_id\x18\x05 \x01(\tR\x15alternativeLocationId\x12#\n" +
	"\rredis_version\x18\a \x01(\tR\fredisVersion\x12*\n" +
	"\x11reserved_ip_range\x18\t \x01(\tR\x0freservedIpRange\x12,\n" +
	"\x12secondary_ip_range\x18\x1e \x01(\tR\x10secondaryIpRange\x12\x12\n" +
	"\x04host\x18\n" +
	" \x01(\tR\x04host\x12\x12\n" +
	"\x04port\x18\v \x01(\x05R\x04port\x12.\n" +
	"\x13current_location_id\x18\f \x01(\tR\x11currentLocationId\x12;\n" +
	"\vcreate_time\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12B\n" +
	"\x05state\x18\x0e \x01(\x0e2,.google.events.cloud.redis.v1.Instance.StateR\x05state\x12%\n" +
	"\x0estatus_message\x18\x0f \x01(\tR\rstatusMessage\x12]\n" +
	"\rredis_configs\x18\x10 \x03(\v28.google.events.cloud.redis.v1.Instance.RedisConfigsEntryR\fredisConfigs\x12?\n" +
	"\x04tier\x18\x11 \x01(\x0e2+.google.events.cloud.redis.v1.Instance.TierR\x04tier\x12$\n" +
	"\x0ememory_size_gb\x18\x12 \x01(\x05R\fmemorySizeGb\x12-\n" +
	"\x12authorized_network\x18\x14 \x01(\tR\x11authorizedNetwork\x128\n" +
	"\x18persistence_iam_identity\x18\x15 \x01(\tR\x16persistenceIamIdentity\x12U\n" +
	"\fconnect_mode\x18\x16 \x01(\x0e22.google.events.cloud.redis.v1.Instance.ConnectModeR\vconnectMode\x12!\n" +
	"\fauth_enabled\x18\x17 \x01(\bR\vauthEnabled\x12T\n" +
	"\x0fserver_ca_certs\x18\x19 \x03(\v2,.google.events.cloud.redis.v1.TlsCertificateR\rserverCaCerts\x12t\n" +
	"\x17transit_encryption_mode\x18\x1a \x01(\x0e2<.google.events.cloud.redis.v1.Instance.TransitEncryptionModeR\x15transitEncryptionMode\x12^\n" +
	"\x12maintenance_policy\x18\x1b \x01(\v2/.google.events.cloud.redis.v1.MaintenancePolicyR\x11maintenancePolicy\x12d\n" +
	"\x14maintenance_schedule\x18\x1c \x01(\v21.google.events.cloud.redis.v1.MaintenanceScheduleR\x13maintenanceSchedule\x12#\n" +
	"\rreplica_count\x18\x1f \x01(\x05R\freplicaCount\x12<\n" +
	"\x05nodes\x18  \x03(\v2&.google.events.cloud.redis.v1.NodeInfoR\x05nodes\x12#\n" +
	"\rread_endpoint\x18! \x01(\tR\freadEndpoint\x12,\n" +
	"\x12read_endpoint_port\x18\" \x01(\x05R\x10readEndpointPort\x12e\n" +
	"\x12read_replicas_mode\x18# \x01(\x0e27.google.events.cloud.redis.v1.Instance.ReadReplicasModeR\x10readReplicasMode\x120\n" +
	"\x14customer_managed_key\x18$ \x01(\tR\x12customerManagedKey\x12^\n" +
	"\x12persistence_config\x18% \x01(\v2/.google.events.cloud.redis.v1.PersistenceConfigR\x11persistenceConfig\x12f\n" +
	"\x12suspension_reasons\x18& \x03(\x0e27.google.events.cloud.redis.v1.Instance.SuspensionReasonR\x11suspensionReasons\x12/\n" +
	"\x13maintenance_version\x18' \x01(\tR\x12maintenanceVersion\x12D\n" +
	"\x1eavailable_maintenance_versions\x18( \x03(\tR\x1cavailableMaintenanceVersions\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a?\n" +
	"\x11RedisConfigsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x94\x01\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bCREATING\x10\x01\x12\t\n" +
	"\x05READY\x10\x02\x12\f\n" +
	"\bUPDATING\x10\x03\x12\f\n" +
	"\bDELETING\x10\x04\x12\r\n" +
	"\tREPAIRING\x10\x05\x12\x0f\n" +
	"\vMAINTENANCE\x10\x06\x12\r\n" +
	"\tIMPORTING\x10\b\x12\x10\n" +
	"\fFAILING_OVER\x10\t\"8\n" +
	"\x04Tier\x12\x14\n" +
	"\x10TIER_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05BASIC\x10\x01\x12\x0f\n" +
	"\vSTANDARD_HA\x10\x03\"[\n" +
	"\vConnectMode\x12\x1c\n" +
	"\x18CONNECT_MODE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eDIRECT_PEERING\x10\x01\x12\x1a\n" +
	"\x16PRIVATE_SERVICE_ACCESS\x10\x02\"i\n" +
	"\x15TransitEncryptionMode\x12'\n" +
	"#TRANSIT_ENCRYPTION_MODE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15SERVER_AUTHENTICATION\x10\x01\x12\f\n" +
	"\bDISABLED\x10\x02\"m\n" +
	"\x10ReadReplicasMode\x12\"\n" +
	"\x1eREAD_REPLICAS_MODE_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16READ_REPLICAS_DISABLED\x10\x01\x12\x19\n" +
	"\x15READ_REPLICAS_ENABLED\x10\x02\"U\n" +
	"\x10SuspensionReason\x12!\n" +
	"\x1dSUSPENSION_REASON_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aCUSTOMER_MANAGED_KEY_ISSUE\x10\x01\"\xd8\x04\n" +
	"\x11PersistenceConfig\x12j\n" +
	"\x10persistence_mode\x18\x01 \x01(\x0e2?.google.events.cloud.redis.v1.PersistenceConfig.PersistenceModeR\x0fpersistenceMode\x12n\n" +
	"\x13rdb_snapshot_period\x18\x02 \x01(\x0e2>.google.events.cloud.redis.v1.PersistenceConfig.SnapshotPeriodR\x11rdbSnapshotPeriod\x12O\n" +
	"\x16rdb_next_snapshot_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x13rdbNextSnapshotTime\x12Q\n" +
	"\x17rdb_snapshot_start_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x14rdbSnapshotStartTime\"J\n" +
	"\x0fPersistenceMode\x12 \n" +
	"\x1cPERSISTENCE_MODE_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bDISABLED\x10\x01\x12\a\n" +
	"\x03RDB\x10\x02\"w\n" +
	"\x0eSnapshotPeriod\x12\x1f\n" +
	"\x1bSNAPSHOT_PERIOD_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bONE_HOUR\x10\x03\x12\r\n" +
	"\tSIX_HOURS\x10\x04\x12\x10\n" +
	"\fTWELVE_HOURS\x10\x05\x12\x15\n" +
	"\x11TWENTY_FOUR_HOURS\x10\x06\"\xa2\x02\n" +
	"\x11MaintenancePolicy\x12;\n" +
	"\vcreate_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12q\n" +
	"\x19weekly_maintenance_window\x18\x04 \x03(\v25.google.events.cloud.redis.v1.WeeklyMaintenanceWindowR\x17weeklyMaintenanceWindow\"\xb1\x01\n" +
	"\x17WeeklyMaintenanceWindow\x12(\n" +
	"\x03day\x18\x01 \x01(\x0e2\x16.google.type.DayOfWeekR\x03day\x125\n" +
	"\n" +
	"start_time\x18\x02 \x01(\v2\x16.google.type.TimeOfDayR\tstartTime\x125\n" +
	"\bduration\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\bduration\"\x80\x02\n" +
	"\x13MaintenanceSchedule\x129\n" +
	"\n" +
	"start_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x12%\n" +
	"\x0ecan_reschedule\x18\x03 \x01(\bR\rcanReschedule\x12P\n" +
	"\x16schedule_deadline_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x14scheduleDeadlineTime\"\xda\x01\n" +
	"\x0eTlsCertificate\x12#\n" +
	"\rserial_number\x18\x01 \x01(\tR\fserialNumber\x12;\n" +
	"\vcreate_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vexpire_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expireTime\x12)\n" +
	"\x10sha1_fingerprint\x18\x05 \x01(\tR\x0fsha1Fingerprint\"f\n" +
	"\x11InstanceEventData\x12E\n" +
	"\apayload\x18\x01 \x01(\v2&.google.events.cloud.redis.v1.InstanceH\x00R\apayload\x88\x01\x01B\n" +
	"\n" +
	"\b_payloadBj\xaa\x02%Google.Events.Protobuf.Cloud.Redis.V1\xca\x02\x1cGoogle\\Events\\Cloud\\Redis\\V1\xea\x02 Google::Events::Cloud::Redis::V1b\x06proto3"

var (
	file_cloud_redis_v1_data_proto_rawDescOnce sync.Once
	file_cloud_redis_v1_data_proto_rawDescData []byte
)

func file_cloud_redis_v1_data_proto_rawDescGZIP() []byte {
	file_cloud_redis_v1_data_proto_rawDescOnce.Do(func() {
		file_cloud_redis_v1_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cloud_redis_v1_data_proto_rawDesc), len(file_cloud_redis_v1_data_proto_rawDesc)))
	})
	return file_cloud_redis_v1_data_proto_rawDescData
}

var file_cloud_redis_v1_data_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_cloud_redis_v1_data_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_cloud_redis_v1_data_proto_goTypes = []any{
	(Instance_State)(0),                    // 0: google.events.cloud.redis.v1.Instance.State
	(Instance_Tier)(0),                     // 1: google.events.cloud.redis.v1.Instance.Tier
	(Instance_ConnectMode)(0),              // 2: google.events.cloud.redis.v1.Instance.ConnectMode
	(Instance_TransitEncryptionMode)(0),    // 3: google.events.cloud.redis.v1.Instance.TransitEncryptionMode
	(Instance_ReadReplicasMode)(0),         // 4: google.events.cloud.redis.v1.Instance.ReadReplicasMode
	(Instance_SuspensionReason)(0),         // 5: google.events.cloud.redis.v1.Instance.SuspensionReason
	(PersistenceConfig_PersistenceMode)(0), // 6: google.events.cloud.redis.v1.PersistenceConfig.PersistenceMode
	(PersistenceConfig_SnapshotPeriod)(0),  // 7: google.events.cloud.redis.v1.PersistenceConfig.SnapshotPeriod
	(*NodeInfo)(nil),                       // 8: google.events.cloud.redis.v1.NodeInfo
	(*Instance)(nil),                       // 9: google.events.cloud.redis.v1.Instance
	(*PersistenceConfig)(nil),              // 10: google.events.cloud.redis.v1.PersistenceConfig
	(*MaintenancePolicy)(nil),              // 11: google.events.cloud.redis.v1.MaintenancePolicy
	(*WeeklyMaintenanceWindow)(nil),        // 12: google.events.cloud.redis.v1.WeeklyMaintenanceWindow
	(*MaintenanceSchedule)(nil),            // 13: google.events.cloud.redis.v1.MaintenanceSchedule
	(*TlsCertificate)(nil),                 // 14: google.events.cloud.redis.v1.TlsCertificate
	(*InstanceEventData)(nil),              // 15: google.events.cloud.redis.v1.InstanceEventData
	nil,                                    // 16: google.events.cloud.redis.v1.Instance.LabelsEntry
	nil,                                    // 17: google.events.cloud.redis.v1.Instance.RedisConfigsEntry
	(*timestamppb.Timestamp)(nil),          // 18: google.protobuf.Timestamp
	(dayofweek.DayOfWeek)(0),               // 19: google.type.DayOfWeek
	(*timeofday.TimeOfDay)(nil),            // 20: google.type.TimeOfDay
	(*durationpb.Duration)(nil),            // 21: google.protobuf.Duration
}
var file_cloud_redis_v1_data_proto_depIdxs = []int32{
	16, // 0: google.events.cloud.redis.v1.Instance.labels:type_name -> google.events.cloud.redis.v1.Instance.LabelsEntry
	18, // 1: google.events.cloud.redis.v1.Instance.create_time:type_name -> google.protobuf.Timestamp
	0,  // 2: google.events.cloud.redis.v1.Instance.state:type_name -> google.events.cloud.redis.v1.Instance.State
	17, // 3: google.events.cloud.redis.v1.Instance.redis_configs:type_name -> google.events.cloud.redis.v1.Instance.RedisConfigsEntry
	1,  // 4: google.events.cloud.redis.v1.Instance.tier:type_name -> google.events.cloud.redis.v1.Instance.Tier
	2,  // 5: google.events.cloud.redis.v1.Instance.connect_mode:type_name -> google.events.cloud.redis.v1.Instance.ConnectMode
	14, // 6: google.events.cloud.redis.v1.Instance.server_ca_certs:type_name -> google.events.cloud.redis.v1.TlsCertificate
	3,  // 7: google.events.cloud.redis.v1.Instance.transit_encryption_mode:type_name -> google.events.cloud.redis.v1.Instance.TransitEncryptionMode
	11, // 8: google.events.cloud.redis.v1.Instance.maintenance_policy:type_name -> google.events.cloud.redis.v1.MaintenancePolicy
	13, // 9: google.events.cloud.redis.v1.Instance.maintenance_schedule:type_name -> google.events.cloud.redis.v1.MaintenanceSchedule
	8,  // 10: google.events.cloud.redis.v1.Instance.nodes:type_name -> google.events.cloud.redis.v1.NodeInfo
	4,  // 11: google.events.cloud.redis.v1.Instance.read_replicas_mode:type_name -> google.events.cloud.redis.v1.Instance.ReadReplicasMode
	10, // 12: google.events.cloud.redis.v1.Instance.persistence_config:type_name -> google.events.cloud.redis.v1.PersistenceConfig
	5,  // 13: google.events.cloud.redis.v1.Instance.suspension_reasons:type_name -> google.events.cloud.redis.v1.Instance.SuspensionReason
	6,  // 14: google.events.cloud.redis.v1.PersistenceConfig.persistence_mode:type_name -> google.events.cloud.redis.v1.PersistenceConfig.PersistenceMode
	7,  // 15: google.events.cloud.redis.v1.PersistenceConfig.rdb_snapshot_period:type_name -> google.events.cloud.redis.v1.PersistenceConfig.SnapshotPeriod
	18, // 16: google.events.cloud.redis.v1.PersistenceConfig.rdb_next_snapshot_time:type_name -> google.protobuf.Timestamp
	18, // 17: google.events.cloud.redis.v1.PersistenceConfig.rdb_snapshot_start_time:type_name -> google.protobuf.Timestamp
	18, // 18: google.events.cloud.redis.v1.MaintenancePolicy.create_time:type_name -> google.protobuf.Timestamp
	18, // 19: google.events.cloud.redis.v1.MaintenancePolicy.update_time:type_name -> google.protobuf.Timestamp
	12, // 20: google.events.cloud.redis.v1.MaintenancePolicy.weekly_maintenance_window:type_name -> google.events.cloud.redis.v1.WeeklyMaintenanceWindow
	19, // 21: google.events.cloud.redis.v1.WeeklyMaintenanceWindow.day:type_name -> google.type.DayOfWeek
	20, // 22: google.events.cloud.redis.v1.WeeklyMaintenanceWindow.start_time:type_name -> google.type.TimeOfDay
	21, // 23: google.events.cloud.redis.v1.WeeklyMaintenanceWindow.duration:type_name -> google.protobuf.Duration
	18, // 24: google.events.cloud.redis.v1.MaintenanceSchedule.start_time:type_name -> google.protobuf.Timestamp
	18, // 25: google.events.cloud.redis.v1.MaintenanceSchedule.end_time:type_name -> google.protobuf.Timestamp
	18, // 26: google.events.cloud.redis.v1.MaintenanceSchedule.schedule_deadline_time:type_name -> google.protobuf.Timestamp
	18, // 27: google.events.cloud.redis.v1.TlsCertificate.create_time:type_name -> google.protobuf.Timestamp
	18, // 28: google.events.cloud.redis.v1.TlsCertificate.expire_time:type_name -> google.protobuf.Timestamp
	9,  // 29: google.events.cloud.redis.v1.InstanceEventData.payload:type_name -> google.events.cloud.redis.v1.Instance
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_cloud_redis_v1_data_proto_init() }
func file_cloud_redis_v1_data_proto_init() {
	if File_cloud_redis_v1_data_proto != nil {
		return
	}
	file_cloud_redis_v1_data_proto_msgTypes[7].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cloud_redis_v1_data_proto_rawDesc), len(file_cloud_redis_v1_data_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cloud_redis_v1_data_proto_goTypes,
		DependencyIndexes: file_cloud_redis_v1_data_proto_depIdxs,
		EnumInfos:         file_cloud_redis_v1_data_proto_enumTypes,
		MessageInfos:      file_cloud_redis_v1_data_proto_msgTypes,
	}.Build()
	File_cloud_redis_v1_data_proto = out.File
	file_cloud_redis_v1_data_proto_goTypes = nil
	file_cloud_redis_v1_data_proto_depIdxs = nil
}
